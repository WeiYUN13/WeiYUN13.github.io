<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>linker script</title>
    <link href="/2022/11/06/linker-script/"/>
    <url>/2022/11/06/linker-script/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Andes-SAG"><a href="#1-Andes-SAG" class="headerlink" title="1. Andes SAG"></a>1. Andes SAG</h1><blockquote><p><a href="http://www.andestech.com/wp-content/uploads/Andes-%E7%9A%84%E5%88%86%E6%95%A3%E8%81%9A%E5%90%88%EF%BC%88SAG%EF%BC%89%E6%9C%BA%E5%88%B6.pdf">http://www.andestech.com/wp-content/uploads/Andes-%E7%9A%84%E5%88%86%E6%95%A3%E8%81%9A%E5%90%88%EF%BC%88SAG%EF%BC%89%E6%9C%BA%E5%88%B6.pdf</a></p><p><a href="http://www.andestech.com/wp-content/uploads/Andes-SaG-Application-Examples.pdf">http://www.andestech.com/wp-content/uploads/Andes-SaG-Application-Examples.pdf</a></p></blockquote><p>linker script负责控制链接过程，链接脚本的主要目的是描述如何将输入文件中的各个部分映射到输出文件中，并控制输出文件的内存布局。控制ELF文件的加载地址和虚拟内存地址。</p><p>SAG 机制能够将加载和运行时存储器中 的代码和数据描述在一个 SAG 格式的文本描述文件中，并通过 link generator tool将SAG文件转化为标准GNU的link script文件，以供链接时使用。</p><h2 id="1-LMA-vs-VMA"><a href="#1-LMA-vs-VMA" class="headerlink" title="1. LMA vs VMA"></a>1. LMA vs VMA</h2><blockquote><p>VMA (Virtual Memory Address) and LMA  (Load Memory Address)</p></blockquote><p>一般在嵌入式系统中，程序存储和运行在不同的地址空间，LMA 表示的是程序装载地址，VMA 表示的是程序运行地址，LMA 不等于 VMA 时程序在加载后不可直接运行，程序运行前，要把程序的内容，拷贝到对应的内存地址处，才能正确地运行。</p><p>可以展开的是，可执行文件一般最终被烧录至硬盘中，如Flash。而Flash并非是RAM，因此部分只读数据可以存储在Flash中，但是其他需要读写的section必须后续再加载到嵌入式系统的其他内存部分。此时Flash即为LMA，RAM即为VMA。</p><p>linker script需要定义每一个section的是否需要拷贝到RAM以及拷贝地址。</p><h2 id="2-linker-script-keywords"><a href="#2-linker-script-keywords" class="headerlink" title="2. linker script keywords"></a>2. linker script keywords</h2><p><img src="/2022/11/06/linker-script/image-20221107150334285.png" alt="image-20221107150334285"></p><ul><li>LOADADDR：获取加载地址，即Flash地址，可以理解成LMA地址</li><li>ADDR：获取VMA地址，即执行内存地址</li><li>AT：当前section的加载地址，需要从LMA地址上加载到内存中</li><li>location counter(LC)：若不强行赋值，LC则递增</li></ul><p>一个误区是，0x10000指的是VMA地址，而真实的LMA地址中text，data和bss是连续的。另一个理解是LMA地址连续可以使ELF文件体积更小。</p><h2 id="3-ELF段信息"><a href="#3-ELF段信息" class="headerlink" title="3. ELF段信息"></a>3. ELF段信息</h2><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Sections</span>:<br><span class="hljs-attribute">Idx</span> Name          Size      VMA       LMA       File <span class="hljs-literal">off</span>  Algn<br><span class="hljs-attribute">14</span> <span class="hljs-string">&quot;.*_retention_data_*&quot;</span>  <span class="hljs-number">00000036</span>  <span class="hljs-number">80000000</span>  b00283a6  <span class="hljs-number">00028740</span>  <span class="hljs-number">2</span>**<span class="hljs-number">3</span><br>                  <span class="hljs-attribute">CONTENTS</span>, ALLOC, LOAD, DATA<br><br></code></pre></td></tr></table></figure><p>section14的header信息中表示LMA地址为b00283a6，会被加载到VMA地址80000000执行。数据段会被修改，因此不能存在于Flash中。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Sections:<br>Idx Name        Size      VMA       LMA       File off  Algn<br><span class="hljs-number">4</span> .boot         <span class="hljs-number">000000b2</span>  b0000320  b0000320  <span class="hljs-number">00000520</span>  <span class="hljs-number">2</span>**<span class="hljs-number">2</span><br>                CONTENTS, ALLOC, LOAD, READONLY, CODE<br></code></pre></td></tr></table></figure><p>boot section由于只是只读的段，依然在Flash中，不需要加载。</p>]]></content>
    
    
    <categories>
      
      <category>c</category>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linker script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机组件</title>
    <link href="/2022/11/03/mcu-key-components/"/>
    <url>/2022/11/03/mcu-key-components/</url>
    
    <content type="html"><![CDATA[<h1 id="MCU关键组件介绍"><a href="#MCU关键组件介绍" class="headerlink" title="MCU关键组件介绍"></a>MCU关键组件介绍</h1><p>总结单片机中的常见重要组件</p><h2 id="1-看门狗计时器"><a href="#1-看门狗计时器" class="headerlink" title="1. 看门狗计时器"></a>1. 看门狗计时器</h2><blockquote><p>watchdog timer: <a href="https://zhuanlan.zhihu.com/p/149328734">https://zhuanlan.zhihu.com/p/149328734</a></p></blockquote><p>用于在MCU主程序由于硬件或者软件问题时跑飞时强制执行硬件复位或者软件复位，达到故障恢复的目的。没有此项功能时，MCU可能卡死。WDT内部内置一个counter，在counter match产生中断时，cpu应及时清除该counter以及中断，在故障时，cpu无法及时清除counter，导致WDT发起reset，主程序复位。</p><img src="mcu-key-components/image-20221103174430424.png" alt="image-20221103174430424" style="zoom:50%;" /><p>extclk作为data输入，而不是作为时钟，决定了counter enable的频率。WDT可以从pclk或者extclk中选择。中断时间和reset时间均可以由WDT controller寄存器配置。</p><img src="mcu-key-components/image-20221103174756661.png" alt="image-20221103174756661" style="zoom:50%;" /><p>watchdog需要cpu的参与，因此cpu在watchdog中断信号时必须处于唤醒状态（或者被watchdog中断信号唤醒）</p><h3 id="1-interrupt"><a href="#1-interrupt" class="headerlink" title="1. interrupt"></a>1. interrupt</h3><p>WDT中断连接至cpu的non-maskable interrupt (NMI)，不可被软件disable。这样的配置最大程度上能保证WDT中断的正常执行。</p><blockquote><p>From AndesCore N25f datasheet</p></blockquote><blockquote><p>Non-maskable interrupts (NMIs) are intended for handling hardware error conditions and are assumed to be non-resumable. They are triggered through the nmi input signal. The rising edge of the signal causes an immediate jump to an address stored in the mnvec register and transition of the privilege level to M-mode, regardless of the state of a hart’s interrupt enable bit.</p></blockquote><h2 id="2-DMA"><a href="#2-DMA" class="headerlink" title="2. DMA"></a>2. DMA</h2><p>Direct memory access，直接内存访问模块，可以直接通过总线传输数据。将CPU从繁重的数据转移工作中转移出来，从而CPU可以进行更多的计算工作。</p><p>常见的AHB master有CPU以及DMA，AHB master可以通过AHB bus对总线上的外设内存直接读取以及写入，因此作为AHB master的DMA也可以搬运数据，减轻了CPU的工作负担。</p><img src="mcu-key-components/image-20221104110149834.png" alt="image-20221104110149834" style="zoom:50%;" /><p>AHB master：DMA controller主动发起内存数据的传输。</p><p>AHB slave：DMA controller同时也是ahb slave，可以被CPU读写寄存器控制DMA。</p><h3 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1. 工作流程"></a>1. 工作流程</h3><p>Andes DMA controller提供8个DMA channel，每个channel均可独立配置，DMA controller通过仲裁器，优先为高优先级（channel优先级可配置，同优先级的轮询调度）的channel执行单个transaction，DMA transfers可由多个transactions构成。</p><p><img src="/2022/11/03/mcu-key-components/image-20221104111148376.png" alt="image-20221104111148376"></p><p>在DMA transfers执行完成或出现错误或放弃时，产生DMA中断交由CPU处理。</p><p>DMA传输支持三种地址控制模式，递增递减以及固定地址。固定地址可以与如uart进行数据传输，固定地址绑定到uart的THR或者RBR寄存器。</p><h3 id="2-Hardware-Handshaking"><a href="#2-Hardware-Handshaking" class="headerlink" title="2. Hardware Handshaking"></a>2. Hardware Handshaking</h3><p>提供给低速设备的一套最多32组的硬件握手信号dma_req&#x2F;dma_ack，由dma_req控制数据的传输，数据传输完成后拉高dma_ack。避免由于低速设备导致AHB bus被长时间占用。如从uart RX FIFO搬运数据时，如RX FIFO数据量达到一定阈值时会触发dma_req信号。</p><p><img src="/2022/11/03/mcu-key-components/image-20221104135243604.png" alt="image-20221104135243604"></p><p>每个channel的控制寄存器均可配置该channel选择的握手信号pair，channel数据传输由该pair控制。并可配置是否启动握手模式。</p><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs vim">SrcReqSel <span class="hljs-number">11</span>:<span class="hljs-number">8</span> R/W <br>Bits <span class="hljs-number">4</span>~<span class="hljs-number">0</span> of the <span class="hljs-keyword">source</span> DMA request selection.&#123;SrcReqSelB5, SrcReqSel&#125; select the request/ack handshake pair that the <span class="hljs-keyword">source</span> device <span class="hljs-keyword">is</span> connected <span class="hljs-keyword">to</span>.<br><br>DstReqSel <span class="hljs-number">7</span>:<span class="hljs-number">4</span> R/W <br>Bits <span class="hljs-number">4</span>~<span class="hljs-number">0</span> of the destination DMA request selection. &#123;DstReqSelB5, DstReqSel&#125; select the request/ack handshake pair that the destination device <span class="hljs-keyword">is</span> connected <span class="hljs-keyword">to</span>.<br><br>SrcMode <span class="hljs-number">17</span> R/W Source DMA handshake <span class="hljs-keyword">mode</span><br><span class="hljs-number">0</span>x0: <span class="hljs-keyword">normal</span> <span class="hljs-keyword">mode</span><br><span class="hljs-number">0</span>x1: handshake <span class="hljs-keyword">mode</span><br><br>DstMode <span class="hljs-number">16</span> R/W Destination DMA handshake <span class="hljs-keyword">mode</span><br><span class="hljs-number">0</span>x0: <span class="hljs-keyword">normal</span> <span class="hljs-keyword">mode</span><br><span class="hljs-number">0</span>x1: handshake <span class="hljs-keyword">mode</span><br></code></pre></td></tr></table></figure><h3 id="3-DMA链式传输"><a href="#3-DMA链式传输" class="headerlink" title="3. DMA链式传输"></a>3. DMA链式传输</h3><p>DMA一般只提供原地址，目标地址，数据长度以及transfer size，这样单个DMA transfers只能搬运连续内存地址的数据。ATCDMAC100提供了链式传输的配置，通过一个链表，其中包含了下一块需要搬运内存的地址</p><p><img src="/2022/11/03/mcu-key-components/image-20221104112142231.png" alt="image-20221104112142231"></p><p>interrupt handling software需要在中断产生后重新使能该channel即可继续链式传输。</p>]]></content>
    
    
    <categories>
      
      <category>chip</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serial</title>
    <link href="/2022/10/13/serial/"/>
    <url>/2022/10/13/serial/</url>
    
    <content type="html"><![CDATA[<h1 id="串口基础"><a href="#串口基础" class="headerlink" title="串口基础"></a>串口基础</h1><p>同步通信是指，发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。</p><p>异步通信是指，发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p><p>换句话说，同步通信是阻塞方式，异步通信是非阻塞方式。在常见通信总线协议中，I2C，SPI属于同步通信而UART属于异步通信。同步通信的通信双方必须先建立同步，即双方的时钟要调整到同一个频率，收发双方不停地发送和接收连续的同步比特流。异步通信在发送字符时，发送端可以在任意时刻开始发送字符，所以，在UART通信中，数据起始位和停止位是必不可少的。</p><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><blockquote><p>Universal Asynchronous Receiver&#x2F;Transmitter (UART)</p><p><a href="https://www.circuitbasics.com/basics-uart-communication/">https://www.circuitbasics.com/basics-uart-communication/</a></p></blockquote><p><img src="/2022/10/13/serial/uart.png"></p><p>UART是对称异步通信串口。发送端在任意时刻均可发送数据，接收端若未及时接收则数据丢失。可以看出异步通信要求双方提前等待数据的传输（串口的速度远低于CPU的速度），从而避免数据丢失。UART通信只需要两条导线。</p><p><img src="/2022/10/13/serial/uart_connect.png" alt="uart_connect.png"></p><p>UART通信的基本要求是：</p><ol><li>UART双方保持一致的波特率以及数据包配置，不需要保持一致的时钟频率</li><li>UART双方TX连接到对方的RX</li></ol><h3 id="1-Transmitter"><a href="#1-Transmitter" class="headerlink" title="1. Transmitter"></a>1. Transmitter</h3><p>包含一个Transmitter FIFO (TX FIFO)，Transmitter Shift Register (TSR)，和Transmitter Controller (TX controller)。用于向外界的UART口传输比特流，FIFO以及buffer只用作输出时的缓存，接收端只是被动接受。接收端未及时接收则数据丢失。</p><h4 id="1-Transmitter-FIFO-TX-FIFO"><a href="#1-Transmitter-FIFO-TX-FIFO" class="headerlink" title="1. Transmitter FIFO (TX FIFO)"></a>1. Transmitter FIFO (TX FIFO)</h4><p>存储着需要传输的数据，APB BUS通过写入THR寄存器，可以向FIFO中添加数据。可以软件外置一个buffer，从buffer中向FIFO同步，达到软件上提升FIFO容量的目的。</p><h4 id="2-Transmitter-Shift-Register-TSR"><a href="#2-Transmitter-Shift-Register-TSR" class="headerlink" title="2. Transmitter Shift Register (TSR)"></a>2. Transmitter Shift Register (TSR)</h4><p>TSR移位寄存器每次从FIFO中获取一个字，并将并行数据转换为0101的串行的比特流。</p><h4 id="3-Transmitter-Controller-TX-controller"><a href="#3-Transmitter-Controller-TX-controller" class="headerlink" title="3. Transmitter Controller (TX controller)"></a>3. Transmitter Controller (TX controller)</h4><p>TX controller为比特流添加开始结尾以及奇偶校验信息后输出该比特流至IO pad上。IO pad可以外接到外部的UART RXD引脚。外部的UART 通过该RXD引脚接收芯片UART口的TXD引脚比特流，并解析得到数据。</p><h3 id="2-Reciever"><a href="#2-Reciever" class="headerlink" title="2. Reciever"></a>2. Reciever</h3><p>包含Receiver FIFO (RX FIFO), Receiver Shift Register (RSR), 和Receiver Controller (RX Controller)。接收端接收外界UART TXD口输入的比特流</p><h4 id="1-Receiver-Controller-RX-Controller"><a href="#1-Receiver-Controller-RX-Controller" class="headerlink" title="1. Receiver Controller (RX Controller)"></a>1. Receiver Controller (RX Controller)</h4><p>RX Controller通过过采样时钟采样输入的比特流（每个过采样率下采样一次）并校验，这个过程与TX controller相反。要求两个UART有相同的波特率。</p><h4 id="2-Receiver-Shift-Register-RSR"><a href="#2-Receiver-Shift-Register-RSR" class="headerlink" title="2. Receiver Shift Register (RSR)"></a>2. Receiver Shift Register (RSR)</h4><p>RX Controller获取的比特流通过RSR移位寄存器转换为字存储至RX FIFO中。</p><h4 id="3-Receiver-FIFO-RX-FIFO"><a href="#3-Receiver-FIFO-RX-FIFO" class="headerlink" title="3. Receiver FIFO (RX FIFO)"></a>3. Receiver FIFO (RX FIFO)</h4><p>CPU可以通过读取RBR寄存器来读取FIFO中的数据。同样可以软件外置一个buffer来提升RX FIFO的容量。与TX FIFO不同的是，RX FIFO能够缓存数据，FIFO以及buffer满后，后续的数据会丢失。Receiver FIFO接收到一定的数据后会触发中断，CPU执行中断程序搬运FIFO数据至buffer。</p><h3 id="3-波特率"><a href="#3-波特率" class="headerlink" title="3. 波特率"></a>3. 波特率</h3><p>uart的波特率即传输bit的速度，通过uart clock分频生成Baud Rate Generator clock，由此clock在oversampling ratio下，每oversampling ratio个cycles对同一个输入bit采样，以及生成对应波特率的输出bit流。</p><p>reciever和transmitter的波特率必需配置相同才能正确的通信。</p><h4 id="过采样"><a href="#过采样" class="headerlink" title="过采样"></a>过采样</h4><p>即对单个数据采样多次，Baud Rate Generator clock在每个cycle下采样，对同一个bit采样oversampling ratio次。START BIT只有半个周期，即只会被采样oversampling ratio &#x2F; 2次。</p><p>一定的过采样能够有效的抑制时钟周期不稳定对数据传输的影响。</p><h3 id="4-Modem-controller"><a href="#4-Modem-controller" class="headerlink" title="4. Modem controller"></a>4. Modem controller</h3><blockquote><p>不被大多数的UART设备使用</p></blockquote><p>提供自动的数据流控制功能，通过一组RTS(Request to send)&#x2F;CTS(Clear to send)信号连接到对应UART的该信号上（RTS连接到CTS，CTS连接到RTS）。通过控制RTS的信号值，控制通信对方UART CTS值，CTS拉低时不再继续传输数据，达到控制数据流的作用。</p><p>TXFIFO里有数据的时候，如果没有flow control，数据则会立即被发送出去。</p><h3 id="5-DMA"><a href="#5-DMA" class="headerlink" title="5. DMA"></a>5. DMA</h3><p>可以为RXFIFO或者TXFIFO在某个阈值下触发DMA操作。对于transmitter，可以配置DMA将芯片某处数据搬运至THR寄存器，从而向外传输数据。对于reciever，DMA 将RBR寄存器数据搬运值芯片某处，达到读取uart的效果。</p><p>DMA搬运数据不依赖总线以及CPU，能够节省CPU时间。</p><h3 id="6-中断"><a href="#6-中断" class="headerlink" title="6. 中断"></a>6. 中断</h3><p>uart有多个中断信号，可以将所有中断信号or后输出至CPU，使得一个uart设备只占用一个中断。在中断处理程序IRQ中对多个uart中断信号分开处理。</p><ol><li>Receiver line status：传输过程中的错误导致的中断或数据overrun丢失，读取LSR寄存器后清空</li><li>Received data available：RXFIFO数据量超出阈值，读取RBR寄存器至低于阈值后清空</li><li>Character timeout: RXFIFO初始态，读取RBR寄存器后清空</li><li>Transmitter Holding Register empty：transmitter FIFO置空。重新写入字清空。</li><li>Modem status：调制解调器事件发生，如CTS被拉低</li></ol><p>uart中断可以很好的触发内置FIFO和软件外置bufferd的数据同步，如在Received data available时读取RXFIFO数据至外置buffer，或者在Transmitter Holding Register empty时从外置的buffer中取数据写入TXFIFO。</p><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><blockquote><p>General purpose I&#x2F;O (GPIO)  通用输入输出</p></blockquote><p>GPIO作为通用的输入输出口，可以由软件配置为输入或者输出，或者即是输入也是输出。通俗地说，就是一些引脚，可以通过它们<strong>输出高低电平</strong>或者通过它们读入引脚的状态是高电平或是低电平。一定程度上能够复用芯片上不多的pin，达到输入和输出的目的。</p><p><img src="/2022/10/13/serial/image-20221102110505354.png" alt="image-20221102110505354"></p><p>每个GPIO channel可以单独配置为输入或输出，作为输入时GPIO controller对输入信号采样，降噪(de-bounce)，产生中断。作为输出时可以在pull-up或者pull-down配置下输出信号。</p><h3 id="1-pull-up和pull-down"><a href="#1-pull-up和pull-down" class="headerlink" title="1. pull-up和pull-down"></a>1. pull-up和pull-down</h3><blockquote><p><a href="https://raspberrypi.stackexchange.com/questions/4569/what-is-a-pull-up-resistor-what-does-it-do-and-why-is-it-needed">https://raspberrypi.stackexchange.com/questions/4569/what-is-a-pull-up-resistor-what-does-it-do-and-why-is-it-needed</a></p><p>理解什么是上拉电阻和下拉电阻</p></blockquote><img src="serial/image-20221102134334435.png" alt="image-20221102134334435" style="zoom:50%;" /><p>避免由于输入pin处于floating状态下不确定的电平，使用上拉电阻将输入默认至高，下拉电阻将输入默认至低。在某个pin浮动时通过一个电阻将其状态确定下来。</p><blockquote><p><a href="http://bbs.eeworld.com.cn/thread-1070283-1-1.html">http://bbs.eeworld.com.cn/thread-1070283-1-1.html</a></p></blockquote><p>IO端口通常会有一些配置上拉下拉的选项。</p><h3 id="2-GPIO-signals"><a href="#2-GPIO-signals" class="headerlink" title="2. GPIO signals"></a>2. GPIO signals</h3><p>gpio_in[N:0]   Input      PAD GPIO input data</p><p>gpio_oe[N:0]     Output   PAD GPIO output data enable signal. Active high(channel direction register作为输出)</p><p>gpio_out[N:0]   Output   PAD  GPIO output data</p><p>gpio_pullup[N:0]  Output.  PAD GPIO output pull-up enable signal</p><p>gpio_pulldown[N:0]    Output   PAD  GPIO output pull-down enable signal</p><p>gpio_intr   Output   Interrupt controller   ATCGPIO100 interrupt signal</p><p>extclk                            Input      Clock generator         External de-bouncing clock source. The clock source must be at least 4x slower than pclk.</p><h3 id="3-channel-control"><a href="#3-channel-control" class="headerlink" title="3. channel control"></a>3. channel control</h3><p>寄存器控制每个GPIO channel，包括输入输出数据，以及pull类型配置。</p><h3 id="4-de-bounce-control"><a href="#4-de-bounce-control" class="headerlink" title="4. de-bounce control"></a>4. de-bounce control</h3><p>寄存器控制输入降噪，包括每个channel降噪开启，降噪时钟源的选择，以及降噪的scale</p><h3 id="5-interrupt-control"><a href="#5-interrupt-control" class="headerlink" title="5. interrupt control"></a>5. interrupt control</h3><p>寄存器控制中断，包括中断的开启，中断状态，以及每个channel的中断触发模式（高电平，低电平，上升沿，下降沿，dual edge）。通过中断来调用CPU处理GPIO的输入数据。</p><h3 id="6-usage"><a href="#6-usage" class="headerlink" title="6. usage"></a>6. usage</h3><p>GPIO通常作为通用的IO输入输出，通常最终会被连接到芯片的输入输出引脚上。由于不只是GPIO需要输出，像uart， spi以及芯片内部的信号需要输出，经常输出引脚的数量低于需求量。因此可以在芯片内设置IOmux，通过寄存器选择需要输出的信号，达到IO pad有效复用的目的。</p><p>可以说IO pad里实现了一个GPIO，通过与内部的ATCGPIO控制的GPIO通信，同时也可以在硬件中配置与其他的信号相互连接。</p>]]></content>
    
    
    <categories>
      
      <category>“UART”</category>
      
    </categories>
    
    
    <tags>
      
      <tag>串口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prn码</title>
    <link href="/2022/10/10/prn%E7%A0%81/"/>
    <url>/2022/10/10/prn%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>PRN码确保了不同的卫星信号之间不会相互干扰，能够被接收机同时接收且解析</p></blockquote><h1 id="伪随机噪声序列"><a href="#伪随机噪声序列" class="headerlink" title="伪随机噪声序列"></a>伪随机噪声序列</h1><h2 id="1-随机序列"><a href="#1-随机序列" class="headerlink" title="1. 随机序列"></a>1. 随机序列</h2><p>以码周期为$T_{c}$随机二进制序列，序列长度无限，即序列中只有-1或者1的代数值（或者0和1的逻辑值）。自相关性计算即是在每个码周期代数域乘的总和，总和越大，自相关性越好。即</p><p>​$R_{xx} &#x3D; \frac{1}{NT_{c}}\int_{0}^{NT_{c}}S(t)S(t+\tau)dt$</p><p>具有的特性是：</p><ul><li>零延时的自相关性为1，即为最大值</li><li>固定延时$\tau$为$T_{c}$整数倍时，因为码片之间完全随机（随机+1或-1），自相关值为0</li><li>固定延时$\tau$不到一个码片长度时，每个码片时间$T_{c}$上只有$T_{c} - \tau$的时长相同码片相乘，因为自相关值为$1 - \frac{\tau}{T_{c}}$</li><li>固定延时$\tau$大于一个码片长度时但不是整数倍，因为码片之间完全随机（随机+1或-1），自相关值为0</li></ul><h2 id="2-伪随机序列"><a href="#2-伪随机序列" class="headerlink" title="2. 伪随机序列"></a>2. 伪随机序列</h2><p>PRN码在有限长度内随机，并将此随机有限序列无限循环。PRN码码片数$N$，码周期为$T_{c}$，PRN码重复周期为$NT_{c}$。码速率即为产生码片的频率，$R_{c} &#x3D; \frac{1}{T_{c}}$。</p><h3 id="1-最大长度PRN序列"><a href="#1-最大长度PRN序列" class="headerlink" title="1. 最大长度PRN序列"></a>1. 最大长度PRN序列</h3><p>也叫做移位寄存器码，m位移位寄存器在适当反馈下能够产生长度为$2 ^ m -1$长度的PRN码。</p><p>解释：也就是PRN码通过m位移位寄存器产生，由于m位移位寄存器最多只有$2 ^ m -1$个状态（除开全0状态），从某个初态开始，移位寄存器输出一位并更新状态，在设计最好的情况下，遍历所有状态后回到初始态，继续生成同样的序列。通过移位寄存器的方式，产生重复的PRN码。</p><p>特性：</p><ol><li>1比0的数量多1，即-1的数量比1的数量多1</li><li>序列与移位后的序列异或，将产生不同移位的相同序列，即$s(t + N_{1}T_{c}) \oplus s(t + N_{2}T_{c}) &#x3D; s(t + N_{3}T_{c})$</li></ol><p><u>不懂为什么</u>：TODO</p><ul><li><p>固定延时$\tau$为$T_{c}$整数倍时，因为码片长度固定，自相关值很小，但不为0，具体值取决于PRN序列。自相关值为：$R_{xx}(NT_{c}) &#x3D; \frac{1}{NT_{c}}\int_{0}^{NT_{c}}S(t)S(t+\tau)dt &#x3D; -\frac{1}{N}$</p><p>可从特性2推断出。当N越大时，PRN序列接近于随机序列。</p></li></ul><h3 id="2-PRN码的生成"><a href="#2-PRN码的生成" class="headerlink" title="2. PRN码的生成"></a>2. PRN码的生成</h3><p>可以通过伽罗华域（Galois Field）来生成PRN码</p><h4 id="1-有限域基础"><a href="#1-有限域基础" class="headerlink" title="1. 有限域基础"></a>1. 有限域基础</h4><blockquote><p><a href="https://www.cnblogs.com/xdyixia/p/12576437.html">https://www.cnblogs.com/xdyixia/p/12576437.html</a></p></blockquote><ul><li>有限域的一个重要特性是在加法和乘法上具有封闭性。也就是说对域中的元素进行加法或乘法运算后的结果仍然是域中的元素。</li><li>单位元：加法单位元和乘法单位元。对应地，在域中的单位元有：对于加法单位元，所有元素加上单位元e，等于其本身。对应乘法单位元，所有元素乘上单位e，等于其本身。</li><li>逆元：加法逆元和乘法逆元。逆元就像数学上的倒数，两个元素互为对方的逆元。如果元素a和b互为加法逆元，那么就有 a + b &#x3D; e。若互为乘法逆元，那么就有a * b &#x3D; e</li></ul><p>逆元和单位元取决于具体的加法和乘法的定义。</p><h5 id="1-有限域GF-P"><a href="#1-有限域GF-P" class="headerlink" title="1. 有限域GF(P)"></a>1. 有限域GF(P)</h5><p>模P域，即加法和乘法结果均模P后输出，结果均位于[0, p-1]之间。加法单位元为0，乘法单位元为1。</p><p>对于GF(7)，5 + 6 &#x3D; 11 % 7 &#x3D; 4， 5 * 6 &#x3D; 30 % 7 &#x3D; 2。</p><p>求5的加法逆元，(5 + x) % 7 &#x3D; 0, x &#x3D; 2 </p><p>求5的乘法逆元，(5 * x) % 7 &#x3D; 1, x &#x3D; 3（欧几里得辗转相除法）</p><h5 id="2-有限域GF-p-n"><a href="#2-有限域GF-p-n" class="headerlink" title="2. 有限域GF(p^n)"></a>2. 有限域GF(p^n)</h5><p>多项式域上定义的加法和乘法和一般的加法与乘法不同。不同于模P域，GF(p^n)需要模上本原多项式（<strong>本原多项式不能表示为其他两个多项式相乘的乘积</strong>）。</p><p>GF(2^3)元素推导,合并同类项时，系数们进行<strong>异或操作，不是平常的加法操作</strong>，本原多项式为$ x ^ 3 + x + 1$</p><table><thead><tr><th>元素</th><th>多项式表示</th><th>备注</th><th>二进制数</th></tr></thead><tbody><tr><td>$ x ^ 0$</td><td>1</td><td></td><td>1</td></tr><tr><td>$ x ^ 1$</td><td>$ x ^ 1$</td><td></td><td>2</td></tr><tr><td>$ x ^ 2$</td><td>$ x ^ 2$</td><td></td><td>4</td></tr><tr><td>$ x ^ 3$</td><td>$ x + 1$</td><td>$ x ^ 3 mod\ p &#x3D; x + 1$</td><td>3</td></tr><tr><td>$ x ^ 4$</td><td>$ x ^ 2 + x$</td><td></td><td>6</td></tr><tr><td>$ x ^ 5$</td><td>$ x ^ 2 + x + 1$</td><td>$ (x ^ 3 + x ^ 2) mod\ p &#x3D;  x ^ 2 + x + 1$</td><td>7</td></tr><tr><td>$ x ^ 6$</td><td>$ x ^ 2 + 1$</td><td>$ (x ^ 3 + x ^ 2 + x) mod\ p &#x3D;  x ^ 2 + 1$</td><td>5</td></tr><tr><td>$ x ^ 7 &#x3D; x ^ 0$</td><td>1</td><td>$ (x ^ 3 +  x) mod\ p &#x3D;  1$</td><td>1</td></tr><tr><td>0</td><td>0</td><td>加法元</td><td>0</td></tr></tbody></table><p>生成元：生成元是域上的一类特殊元素，生成元的幂可以遍历域上的所有元素。域中所有的元素都可以表示为生成元的幂次。</p><h5 id="3-查表法快速计算"><a href="#3-查表法快速计算" class="headerlink" title="3. 查表法快速计算"></a>3. 查表法快速计算</h5><p>正表：二进制数对应到多项式系数</p><p>反表：多项式系数对应二进制数</p><p><strong>GF(p^n)上的计算会讲二进制数映射到多项式乘法后再映射回到二进制数</strong></p><table><thead><tr><th>$i$</th><th>$gflog[i]$</th><th>$gfilog[i]$</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>1</td></tr><tr><td>1</td><td>0</td><td>2</td></tr><tr><td>2</td><td>1</td><td>4</td></tr><tr><td>3</td><td>3</td><td>3</td></tr><tr><td>4</td><td>2</td><td>6</td></tr><tr><td>5</td><td>6</td><td>7</td></tr><tr><td>6</td><td>4</td><td>5</td></tr><tr><td>7</td><td>5</td><td>-</td></tr></tbody></table><p>比如：计算4 * 5 </p><ul><li>转到多项式，此时计算的是x的系数，乘法变加法：gflog[4] + gflog[5] &#x3D; （2 + 6）% 7 &#x3D; 1</li><li>转到二进制，从x的一次方查表得到二进制数为:gfilog[1] &#x3D; 2</li><li>得到4 * 5 &#x3D; 2</li></ul><p>比如：计算 4 &#x2F; 5</p><ul><li><p>转到多项式，此时计算的是x的系数，乘法变减法：gflog[4] - gflog[5] &#x3D; （2 - 6）% 7 &#x3D; 3</p></li><li><p>转到二进制，从x的三次方查表得到二进制数为:gfilog[3] &#x3D; 3</p></li><li><p>得到4 * 5 &#x3D; 3</p></li></ul><h4 id="2-伽罗华域生成PRN码"><a href="#2-伽罗华域生成PRN码" class="headerlink" title="2. 伽罗华域生成PRN码"></a>2. 伽罗华域生成PRN码</h4><p>如GF(2^3)可以有7种不同的状态，对应7种PRN生成器的状态，每种状态下产生1bit。因此可以生成7位的PRN码。需要设计触发方式，使得生成器从初始态遍历所有状态后回到初始态。</p><ol><li>$ a_{j} \implies a_{j+1}$</li><li>$ a ^ n &#x3D; a ^ 0, n &#x3D; 2 ^ m -1$</li></ol><p>初始态任意选择，<strong>并确定一个不可约多项式</strong>，根据GF(2^m)的特性，在$ 2 ^ m - 1$次后将回到初始态。</p><p>通过对每一个状态做映射，可以得到循环码。</p><p>对于每个不可约多项式，都能得到一个码序列。如GF(2^3)有两个码序列，不可约多项式分别为$ x ^ 3 + x ^ 2 + x$和 $ x ^ 3 + x + 1$，因此有两个PRN码序列</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算不可约多项式对应的PRN码</span><br><span class="hljs-keyword">import</span> math<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shift</span>(<span class="hljs-params">register: <span class="hljs-built_in">list</span>, feedback: <span class="hljs-built_in">list</span>, output: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Shift Register</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param list feedback: which positions to use as feedback</span><br><span class="hljs-string">    :param list output: which positions are output</span><br><span class="hljs-string">    :returns output of shift register:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    outs = [register[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output]<br>    out = <span class="hljs-built_in">sum</span>(outs) % <span class="hljs-number">2</span>  <span class="hljs-comment"># one bit each state</span><br><br>    <span class="hljs-comment"># update the register with GF</span><br>    msb = register[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(register)-<span class="hljs-number">1</span>)):<br>        register[i+<span class="hljs-number">1</span>] = register[i]<br>    register[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># feedback is Primitive Polynomial</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> feedback:<br>        register[i] = register[i] ^ msb<br>    <span class="hljs-keyword">return</span> out<br><br><br>num_states = <span class="hljs-number">7</span><br><span class="hljs-comment"># shift register initial state</span><br>register = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(math.log2(num_states)) + <span class="hljs-number">1</span>)]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_states):<br>    <span class="hljs-comment"># Primitive Polynomial x^3 + x + 1</span><br>    out = shift(register=register, feedback=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], output=[-<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(out, register)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------&quot;</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_states):<br>    <span class="hljs-comment"># Primitive Polynomial x^3 + x^2 + 1</span><br>    out = shift(register=register, feedback=[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], output=[-<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(out, register)<br><br></code></pre></td></tr></table></figure><h4 id="3-Gold码"><a href="#3-Gold码" class="headerlink" title="3. Gold码"></a>3. Gold码</h4><p>随着比特数增加，ML PRN码的数量急剧增加，但是ML PRN码之间有一定的互相关性，不能用于导航系统中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>定位基础</title>
    <link href="/2022/09/14/positionning/"/>
    <url>/2022/09/14/positionning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一篇关于GPS定位写得最详实清晰的文章（上） - 枯荣有常的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/150435858">https://zhuanlan.zhihu.com/p/150435858</a></p></blockquote><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><h2 id="1-agps辅助定位"><a href="#1-agps辅助定位" class="headerlink" title="1. agps辅助定位"></a>1. agps辅助定位</h2><p>在传统GPS定位方式中，定位模块需要全频段搜索以找到可用卫星，因而耗时较长。而“AGPS辅助定位”方式，是通过网络直接下载当前地区的可用卫星星历数据，并通过串口设备将之发送给定位模块，定位模块只搜索特定的卫星，从而提高了搜星速度，减少设备耗电。</p><h3 id="1-AGPS辅助定位基本流程"><a href="#1-AGPS辅助定位基本流程" class="headerlink" title="1. AGPS辅助定位基本流程"></a>1. AGPS辅助定位基本流程</h3><ol><li>设备从蜂窝基站获取到当前位置的小区信息；</li><li>设备通过<a href="https://www.zhihu.com/search?q=%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22150435858%22%7D">蜂窝网络</a>，将当前蜂窝小区信息传送给网络中的AGPS位置服务器；</li><li>APGS位置服务器根据当前小区信息查询该区域当前可用的卫星信息（包括卫星的频段、方位、仰角等相关信息），生成对应星历文件，并返回给设备；</li><li>通信模块通过串口把收到的星历文件传输给定位模块；</li><li>定位模块根据星历文件，得到的可用卫星信息，快速找到当前可用的GPS卫星，针对性的搜星，大大提升定位时间。</li></ol><h3 id="2-AGPS辅助定位数据"><a href="#2-AGPS辅助定位数据" class="headerlink" title="2. AGPS辅助定位数据"></a>2. AGPS辅助定位数据</h3><ol><li>GPS leap second(闰秒)</li></ol><p>科学上有两种时间计量系统：基于地球自转的天文测量而得出的“<a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%97%B6?fromModule=lemma_inlink">世界时</a>”和以原子振荡周期确定的“<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%97%B6?fromModule=lemma_inlink">原子时</a>”。“世界时”由于地球自转的不稳定（由地球物质分布不均匀和其它星球的摄动力等引起的）会带来时间的差异，“原子时”（一种较恒定的时制，由原子钟得出）则是相对恒定不变的。这两种时间尺度速率上的差异，一般来说一至二年会差大约1秒时间。</p><p>1971年<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%AE%A1%E9%87%8F%E5%A4%A7%E4%BC%9A?fromModule=lemma_inlink">国际计量大会</a>通过决议：使用“<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6?fromModule=lemma_inlink">协调世界时</a>”来计量时间。当“协调世界时”和“世界时”之差超过0.9秒时，国际地球自转服务组织（IERS）就负责对“协调世界时”拨快或拨慢1秒，这就是闰秒。</p><p>地面的接收机使用的是UTC时间，而人造卫星采用的是原子时时间系统，两个时间单位之间相差即为闰秒。</p><ol start="2"><li>电离层延迟参数 Ionospheric delay parameters</li></ol><p>GPS信号通过电离层时，与其他电磁波一样，信号的路径会发生弯曲，传播速度发生变化，从而使测量的距离发生偏差。</p><figure class="highlight txt"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs txt">GPSA   2.0489E-08  2.2352E-08 -1.1921E-07 -1.1921E-07       IONOSPHERIC CORR    <br>GPSB   1.2493E+05  3.2768E+04 -2.6214E+05  2.6214E+05       IONOSPHERIC CORR    <br></code></pre></td></tr></table></figure><ol start="3"><li>星历数据 ephemerides</li></ol><p>GPS星历是实时的，有效期为星历参考时间的前后两小时，是靠监测站对卫星的实时监测进行更新的，轨道参数精度较高，大概在米级别的；历书是非实时的，有效期一周，只是包含卫星轨道的一些大体的参数，精度很低；星历是用来定位的，而历书一般是用来预测卫星的大体位置，对可能出现在视野内的卫星进行有针对性的捕获，缩短首次定位时间。</p><ol start="4"><li>参考utc时间</li><li>参考位置：经度，纬度，海拔</li></ol>]]></content>
    
    
    <categories>
      
      <category>定位</category>
      
    </categories>
    
    
    <tags>
      
      <tag>positionning</tag>
      
      <tag>GPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crypto</title>
    <link href="/2022/08/15/crypto/"/>
    <url>/2022/08/15/crypto/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h3><p><strong>对称密钥加密</strong>: （英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密（shared secrets），是密码学中的一类加密算法。这类算法在加密和解密时使用<strong>相同的密钥</strong>，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。</p><p><strong>对称密钥加密的主要问题是一旦私钥泄漏，信息即被泄漏。</strong>比如摩斯电码可以被看作是一种对称加密算法，比如将英文字母向右移动一位的规则（凯撒密码，移位密码）也是一种对称加密，只是这种简单的加密方法容易被暴力破解。</p><p>在不安全的环境中如何传递对称加密的私钥也是一个难点。因为密钥一旦被截获，信息则被泄漏。(ECDH密钥协商算法可以通过非对称加密共享得到共享密钥)</p><p>常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6</p><h3 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h3><p><strong>公开密钥加密</strong>（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型。</p><p>在这种密码学方法中，需要一对密钥。一个是<strong>private key</strong>，另一个则是<strong>public key</strong>。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。</p><p>public key用于发送给需要给自己发信息的用户，该用户使用该public key来对自己的信息进行加密，再传输回来。这样即使被截获，黑客也无法破解其中的信息，因为只要该public key对应的private key才能够解密。</p><p>非对称加密常用于SSH, HTTPS, TLS，电子证书，电子签名，电子身份证等等</p><h3 id="3-摘要，电子签名-和-电子证书"><a href="#3-摘要，电子签名-和-电子证书" class="headerlink" title="3. 摘要，电子签名 和 电子证书"></a>3. 摘要，电子签名 和 电子证书</h3><p>非对称加密的一个问题是，发送信息者如何确保自己收到的public key来自于接受信息者。黑客很有可能将自己的public key冒充成接受信息者的key，从而获取到信息。比如在浏览器和服务器之间的数据传输中，需要确认服务器发送给浏览器的public key是来自于该服务器。</p><p>此时该服务器的public key和对应身份需要可信赖机构的认证，公开密钥基础建设负责分发认证申请，并分发电子证书。客户端收到电子证书后可以通过预先安装的根证书，验证该密钥是否对应于该服务器。</p><p>数字证书的生成实际上是用可信赖机构的私钥对服务器公钥和服务器信息加密，生成的。这样客户端通过可信赖机构的公钥解密该证书即可分辨该公钥和服务器信息是否对应。数字证书一般由数字证书认证机构（Certificate Authority）颁发，证书里面包含了真实服务器的公钥和网站的一些其他信息，数字证书机构用自己的私钥加密后发给浏览器，浏览器使用数字证书机构的公钥解密后得到真实服务器的公钥。这个过程是建立在被大家所认可的证书机构之上得到的公钥，所以这是一种安全的方式。</p><h3 id="4-ssh原理"><a href="#4-ssh原理" class="headerlink" title="4. ssh原理"></a>4. ssh原理</h3><blockquote><p><a href="https://www.jellythink.com/archives/555">https://www.jellythink.com/archives/555</a></p></blockquote><p>SSH使用非对称加密的一种通信协议。</p><p>SSH免密登陆的前提是使用<code>ssh-keygen -t RSA</code>生成公私秘钥对，然后通过<code>ssh-copy-id -i ~/.ssh/id_rsa.pub user@host</code>命令将公钥分发至远程主机。接下来的每次免密登陆步骤如下：</p><ol><li>用户使用<code>ssh user@host</code>命令对远程主机发起登陆；</li><li><strong>远程主机对用户返回一个随机串</strong>；</li><li>用户所在主机使用私钥对这个随机串进行加密，并将加密的随机串返回至远程主机；</li><li>远程主机使用分发过来的公钥对加密随机串进行解密；</li><li>如果解密成功，就证明用户的登陆信息是正确的，则允许登陆；否则反之。</li></ol><p>通过<code>ssh-copy-id -i ~/.ssh/id_rsa.pub user@host</code>命令分发的公钥都会被保存至远程主机的<code>~/.ssh/authorized_keys</code>文件中。</p><h3 id="5-哈希算法"><a href="#5-哈希算法" class="headerlink" title="5. 哈希算法"></a>5. 哈希算法</h3><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121">https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121</a></p></blockquote><p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。相同的输入得到相同的输出摘要，不同的输入大概率得到不同的输出。</p><p>哈希碰撞时不可避免的，因为输出的字节数是一定的，所以能够保证不发生碰撞时,最大的输入个数必须大于等于输出的最大个数。而输入是有无限种可能的。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>哈希算法要求碰撞的概率极低，以及难以从输出推测输入。哈希碰撞的概率越低，哈希算法越安全。</p><h2 id="2-对称加密算法"><a href="#2-对称加密算法" class="headerlink" title="2. 对称加密算法"></a>2. 对称加密算法</h2><h3 id="1-XOR加密"><a href="#1-XOR加密" class="headerlink" title="1. XOR加密"></a>1. XOR加密</h3><blockquote><p><a href="http://www.ruanyifeng.com/blog/2017/05/xor.html">http://www.ruanyifeng.com/blog/2017/05/xor.html</a></p></blockquote><p>异或运算的特性是，如果对原始值对一个密钥进行两次异或，会得到这个值本身。刚好可以用于<strong>对称加密</strong>。XOR加密相同的明文会对应相同的密文，这是很大的一个问题。</p><h3 id="2-AES-GCM加密算法"><a href="#2-AES-GCM加密算法" class="headerlink" title="2. AES-GCM加密算法"></a>2. AES-GCM加密算法</h3><blockquote><p><a href="https://juejin.cn/post/6844904122676690951">https://juejin.cn/post/6844904122676690951</a></p></blockquote><p>AES加密就是对称加密的一种，即加密和解密使用相同的一把密钥。它的全称是Advanced Encryption Standard(高级加密标准)，主要是用来取代DES加密算法。</p><p>GCM是<a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/zh-cn/%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86">认证加密</a>模式中的一种，它结合了上述两者的特点(GCM中的G就是指GMAC，C就是指CTR)，能同时确保数据的保密性、完整性及真实性，另外，它还可以提供附加消息的完整性校验。</p><p>AES密钥必须是保密的，而nonce类似于salt，可以随机生成并以明文的方式附在密文后，或者通过相同的shared secret生成相同的nonce。两种方式均可以保证接收方能够收到nonce，而key却是保密的。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs python">shared_secret = ecdh_compute_shared_secret(ecc_key1,ecc_key2)<br>aes_key = SHA256.new(shared_secret + <span class="hljs-string">b&#x27;key&#x27;</span>).digest()[:AES128_KEY_LEN]<br>aes_nonce = SHA256.new(shared_secret + <span class="hljs-string">b&#x27;nonce&#x27;</span>).digest()[:AES_NONCE_SIZE]<br>cipher = AES.new(aes_key, AES.MODE_GCM, nonce=aes_nonce, mac_len=AES_TAG_SIZE)<br></code></pre></td></tr></table></figure><h3 id="3-分组加密"><a href="#3-分组加密" class="headerlink" title="3. 分组加密"></a>3. 分组加密</h3><blockquote><p><a href="https://www.jianshu.com/p/b63095c59361">https://www.jianshu.com/p/b63095c59361</a></p><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)</a></p><p>因为分组加密只能加密固定长度的分组，而实际需要加密的明文可能超过分组长度，此时就要对分组密码算法进行迭代，以完成整个明文加密，迭代的方法就是加密模式。</p></blockquote><p><img src="/2022/08/15/crypto/1717168418a4a08a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="工作模式"></p><h4 id="1-ECB电子密码本"><a href="#1-ECB电子密码本" class="headerlink" title="1. ECB电子密码本"></a>1. ECB电子密码本</h4><p>使用相同的密钥对不同的分组进行加密</p><p>缺乏混淆性，相同的明文对应相同的密文，极可能会暴露数据的pattern。加密一个要点在于相同的明文能够对应不同的密文，以此隐藏数据的模式！</p><h4 id="2-初始向量-IV，Initialization-Vector"><a href="#2-初始向量-IV，Initialization-Vector" class="headerlink" title="2. 初始向量(IV，Initialization Vector)"></a>2. <strong>初始向量(IV，Initialization Vector)</strong></h4><p>为了防止相同的明文对应相同的密文，AES密钥需要随着分组的不同被修改。</p><p><img src="/2022/08/15/crypto/1717168e51d0d403~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="初始向量"></p><h4 id="3-CTR模式"><a href="#3-CTR模式" class="headerlink" title="3. CTR模式"></a>3. CTR模式</h4><p><img src="/2022/08/15/crypto/1717169ba426b17e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="CTR"></p><h2 id="3-非对称加密算法"><a href="#3-非对称加密算法" class="headerlink" title="3. 非对称加密算法"></a>3. 非对称加密算法</h2><h3 id="1-ECC：椭圆曲线密码学"><a href="#1-ECC：椭圆曲线密码学" class="headerlink" title="1. ECC：椭圆曲线密码学"></a>1. ECC：椭圆曲线密码学</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/36326221">https://zhuanlan.zhihu.com/p/36326221</a><br><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</a><br><a href="https://segmentfault.com/a/1190000019172260">https://segmentfault.com/a/1190000019172260</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 曲线方程为 y^2 = x^3 + ax + b</span><br><span class="hljs-meta">@dataclasses.dataclass(<span class="hljs-params">init=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EccCurve</span>:<br>    name: <span class="hljs-built_in">str</span><br>    p: <span class="hljs-built_in">int</span> <span class="hljs-comment"># 有限域点的个数，定义有限域</span><br>    a: <span class="hljs-built_in">int</span> <span class="hljs-comment"># 曲线参数</span><br>    b: <span class="hljs-built_in">int</span> <span class="hljs-comment"># 曲线参数</span><br>    order: <span class="hljs-built_in">int</span> <span class="hljs-comment"># 基点的阶，order * (Gx, Gy) = 0</span><br>    Gx: <span class="hljs-built_in">int</span> <span class="hljs-comment"># 基点为(Gx, Gy)</span><br>    Gy: <span class="hljs-built_in">int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Note: 有限域内逆元的定义 (inv(x) * x) % p = 1，模反元素</span><br><span class="hljs-string">基点 * 私钥 = 公钥</span><br><span class="hljs-string">G  *  d   =  Q</span><br><span class="hljs-string">离散对数问题保证了，已经大数d的情况下计算Q很容易，反推困难。这个特性确保了密钥难以被破解。私钥可以是随机生成的数</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 公钥 point_Q(point_x, point_y)，私钥(d)</span><br>EccKey(curve=<span class="hljs-string">&#x27;NIST P-521&#x27;</span>, point_x=<span class="hljs-number">1878215278705420913809941221673070453630291285278607802615476602600875358248113817201275279498247334786329838442133900179181579335312961075329458832888483454</span>, point_y=<span class="hljs-number">1492631405230049828034629191114631058481712503830618825528196556525243860134770105498486116951576226435160198858744355258829276721863793065418711188792568624</span>, d=<span class="hljs-number">14795520984477726864976711521888896156542260800586806650124809936525264257017938443585197860840835415724634154698356719165115708346614576620653695982388024</span>)<br></code></pre></td></tr></table></figure><h3 id="2-ECDH密钥协商算法"><a href="#2-ECDH密钥协商算法" class="headerlink" title="2. ECDH密钥协商算法"></a>2. ECDH密钥协商算法</h3><blockquote><p><a href="https://www.orchome.com/1049">https://www.orchome.com/1049</a></p></blockquote><p><strong>ECDH能够在不安全的网络传输中安全的分发密钥（共享密钥）</strong>，分发的这个密钥可以作为对称加密的共享密钥。</p><p>基本原理是，双方交换公钥后能够推算出共享密钥，而只有知道其中一个的私钥才能够破解该共享密钥。而ECC的离散对数问题确保了私钥难以被破解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shared_secret = da * Qb = db * Qa = da * db * G<br></code></pre></td></tr></table></figure><p><strong>shared_secret的x点可以作为共享密钥来进行对称加密数据传输</strong>。</p><p>然而ECDH不能够验证公钥是否来自于中间人攻击，即中间人可能将双方交换的公钥替换为自己生成的公钥，从而轻易的破解双方的信息以及伪装为对方通信。因此交换密钥之前可以通过使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥，CA权威机构可以确保该公钥确实来自于对方而不是中间人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ecdh_compute_shared_secret</span>(<span class="hljs-params">self_pri_key: ECC.EccKey,</span><br><span class="hljs-params">                               other_pub_key: ECC.EccKey</span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    <span class="hljs-keyword">assert</span> (self_pri_key.curve == other_pub_key.curve)<br>    point = other_pub_key.pointQ * self_pri_key.d<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(point.x).to_bytes(point.size_in_bytes(), <span class="hljs-string">&#x27;big&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-ECDSA签名算法"><a href="#3-ECDSA签名算法" class="headerlink" title="3. ECDSA签名算法"></a>3. ECDSA签名算法</h3><blockquote><p><a href="https://www.orchome.com/1432">https://www.orchome.com/1432</a></p></blockquote><p><strong>数字签名</strong>：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626">https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626</a></p><p>私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。</p><p>使用数字签名的目的是为了<strong>确认某个信息确实是由某个发送方发送的</strong>，任何人都不可能伪造消息，并且，发送方也不能抵赖。数字签名可以确保该信息确实是由发送方发出的，而不能被伪造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ecdsa_det_sign</span>(<span class="hljs-params">self_pri_key: ECC.EccKey, msg: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    hash_obj = SHA256.new(msg)<br>    signer = DSS.new(self_pri_key,<br>                     mode=<span class="hljs-string">&#x27;deterministic-rfc6979&#x27;</span>,<br>                     encoding=<span class="hljs-string">&#x27;binary&#x27;</span>)<br>    signature = signer.sign(hash_obj)<br>    <span class="hljs-keyword">return</span> signature<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ecdsa_verify</span>(<span class="hljs-params">other_pub_key: ECC.EccKey, msg: <span class="hljs-built_in">bytes</span>, signature: <span class="hljs-built_in">bytes</span></span>):<br>    hash_obj = SHA256.new(msg)<br>    verifier = DSS.new(other_pub_key,<br>                       mode=<span class="hljs-string">&#x27;deterministic-rfc6979&#x27;</span>,<br>                       encoding=<span class="hljs-string">&#x27;binary&#x27;</span>)<br>    verifier.verify(hash_obj, signature)<br></code></pre></td></tr></table></figure><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名。</p>]]></content>
    
    
    <categories>
      
      <category>crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux0.11源码阅读</title>
    <link href="/2022/08/10/Linux0-11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/08/10/Linux0-11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/sunym1993/flash-linux0.11-talk">https://github.com/sunym1993/flash-linux0.11-talk</a></p></blockquote><h1 id="1-进入操作系统内核"><a href="#1-进入操作系统内核" class="headerlink" title="1. 进入操作系统内核"></a>1. 进入操作系统内核</h1><h2 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h2><h3 id="1-固件程序-BIOS启动"><a href="#1-固件程序-BIOS启动" class="headerlink" title="1. 固件程序 BIOS启动"></a>1. 固件程序 <strong>BIOS</strong>启动</h3><p>即为开机启动项，计算机开机后CPU需要执行的第一个程序。BIOS会将磁盘启动区的512个bytes，复制到<strong>0x7c00</strong>的位置，并跳转CPU至该地址执行。操作系统的启动代码即位于该512个bytes中。</p><p>操作系统启动代码的数据地址可以通过设置ds寄存器实现自动的设置基地址，不需要额外去考虑加载到内存后的地址偏移（比如操作系统中数据为一个地址，加载到内存之后这个地址需要根据内存地址修改，实现方式即为ds寄存器）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs assembly">BOOTSEG  = 0x07c0; original address of boot-sector<br>movax,#BOOTSEG<br>movds,ax<br></code></pre></td></tr></table></figure><h3 id="2-复制启动区至0x90000并跳转"><a href="#2-复制启动区至0x90000并跳转" class="headerlink" title="2. 复制启动区至0x90000并跳转"></a>2. 复制启动区至<strong>0x90000</strong>并跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">INITSEG  = 0x9000; we move boot here - out of the way<br>movax,#BOOTSEG<br>movds,ax<br>movax,#INITSEG<br>moves,ax<br>movcx,#256<br>subsi,si<br>subdi,di<br>rep<br>movw<br>jmpigo,INITSEG<br>go:<br>movax,cs<br>movds,ax<br>moves,ax<br></code></pre></td></tr></table></figure><p>rep movm复制cx个字，从ds:si 处复制到 es:di 处。即将将内存地址 0x7c00 处开始往后的 512 字节的数据，原封不动复制到 0x90000 处。并跳转至[INITSEG:go]处执行（go的地址是这个标签在文件内的偏移地址），即执行movax,cs。</p><p>在BIOS执行启动区命令的同时，复制至0x90000并跳转执行。</p><h3 id="3-内存的初步规划"><a href="#3-内存的初步规划" class="headerlink" title="3. 内存的初步规划"></a>3. <strong>内存的初步规划</strong></h3><p>配置数据段寄存器 ds 和代码段寄存器 cs为0x9000，栈顶地址被设置为了 0x9FF00，具体表现为<strong>栈段寄存器 ss</strong> 为 0x9000，<strong>栈基址寄存器 sp</strong> 为 0xFF00。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">go:movax,cs<br>movds,ax<br>moves,ax<br>; put stack at 0x9ff00.<br>movss,ax<br>movsp,#0xFF00; arbitrary value &gt;&gt;512<br></code></pre></td></tr></table></figure><img src="Linux0-11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/640-20220811161801518.png" alt="图片" style="zoom: 67%;" /><h3 id="4-加载操作系统其他部分"><a href="#4-加载操作系统其他部分" class="headerlink" title="4. 加载操作系统其他部分"></a>4. 加载操作系统其他部分</h3><p>通过调用BIOS的0x13号中断程序，从磁盘中加载setup，head至内存中。并跳转至setup的内容开始执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;通过int 0x13加载setup的4个扇区<br>load_setup:<br>movdx,#0x0000; drive 0, head 0<br>movcx,#0x0002; sector 2, track 0<br>movbx,#0x0200; address = 512, in INITSEG<br>movax,#0x0200+SETUPLEN; service 2, nr of sectors<br>int0x13; read it<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;通过int 0x13加载system的240个扇区至0x10000<br>ok_load_setup:<br>    ...<br>    mov ax,#0x1000<br>    mov es,ax       ; segment of 0x10000<br>    call read_it<br>    ...<br>    jmpi 0,0x9020<br></code></pre></td></tr></table></figure><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXQDiaGyIhoIaUMljWXWE6tXOqxVEzPD2d4ibe5UssCqAlpre6eriaf7WEp22yoFSQTtMVf61K18fjsww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" /><h3 id="5-运行setup，获取系统数据"><a href="#5-运行setup，获取系统数据" class="headerlink" title="5. 运行setup，获取系统数据"></a>5. 运行setup，获取系统数据</h3><p>通过调用BIOS中断，系统数据被存储至0x90000-0x901FF，原先存放boot的代码被覆盖。</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>后关闭BIOS中断，并将操作系统代码移动至0x0地址。</p><p><img src="/Linux0-11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/640-20220811172108263.png" alt="图片"></p><h2 id="2-CPU寄存器"><a href="#2-CPU寄存器" class="headerlink" title="2. CPU寄存器"></a>2. CPU寄存器</h2><img src="Linux0-11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/image-20220811111252771.png" alt="image-20220811111252771" style="zoom:33%;" /><h3 id="ds寄存器"><a href="#ds寄存器" class="headerlink" title="ds寄存器"></a>ds寄存器</h3><p>data segment，数据段寄存器。用于在内存寻址时充当段基址的作用。在汇编语言写一个内存地址，只需要写出偏移地址即可。真正的地址为[ds:shift address]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, [0x0001]<br>;等同于<br>mov ax, [ds:0x0001]<br></code></pre></td></tr></table></figure><p>由于 x86 为了让自己在 16 位这个实模式下能访问到 20 位的地址线这个历史因素），所以段基址要先左移四位。即ds的实际值为<code>0x07c0</code></p><h3 id="cs-寄存器"><a href="#cs-寄存器" class="headerlink" title="cs 寄存器"></a>cs 寄存器</h3><p>code segment，<strong>代码段寄存器</strong>，CPU 当前正在执行的代码在内存中的位置，就是由 cs:ip 这组寄存器配合指向的，其中 cs 是基址，ip 是偏移地址。</p><p>执行jmpi go,0x9000后， cs 寄存器里的值就是 <strong>0x9000</strong>，ip 寄存器里的值是 <strong>go</strong> 这个标签的偏移地址。</p><h3 id="ss寄存器"><a href="#ss寄存器" class="headerlink" title="ss寄存器"></a>ss寄存器</h3><p>stack segment, <strong>栈段寄存器</strong>，配合栈基址寄存器 sp 来表示此时的栈顶地址。栈顶地址为 <strong>ss:sp</strong></p><h3 id="sp寄存器"><a href="#sp寄存器" class="headerlink" title="sp寄存器"></a>sp寄存器</h3><p>stack pointer, <strong>栈基址寄存器</strong></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础</title>
    <link href="/2022/07/27/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/27/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ</a></p></blockquote><h2 id="1-交换机，集线器，路由器的区别"><a href="#1-交换机，集线器，路由器的区别" class="headerlink" title="1. 交换机，集线器，路由器的区别"></a>1. 交换机，集线器，路由器的区别</h2><blockquote><p><a href="https://www.jianshu.com/p/6ae0142d5f3a">https://www.jianshu.com/p/6ae0142d5f3a</a></p></blockquote><h3 id="集线器-hub"><a href="#集线器-hub" class="headerlink" title="集线器(hub)"></a>集线器(hub)</h3><p>集线器实际就是一种多端口的中继器。集线器一般有4、8、16、24、32等数量的RJ45接口。中继器的功能是将信号线中衰减的信号重新生成完整的信号。集线器本身不能识别目的地址，当同一局域网内的A主机给B主机传输数据时，数据包在以集线器为架构的网络上是以广播方式传输的，由每一台终端通过验证数据包头的（MAC）地址信息来确定是否接收。</p><p><strong>集线器</strong>，它仅仅是无脑将电信号<strong>转发到所有出口（广播）</strong>，不做任何处理，因此定义在物理层。集线器会讲数据发送给所有的出口设备，效率低下且不安全。</p><p><img src="/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640.gif" alt="图片"></p><h3 id="交换机-switch"><a href="#交换机-switch" class="headerlink" title="交换机(switch)"></a>交换机(switch)</h3><p>交换机内部维护了端口到MAC地址的映射。收到数据包后，会根据目标MAC地址将数据包转发至对应端口上。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。</p><p>交换机位于数据链路层，交换机内部维护一张 <strong>MAC 地址表</strong>，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。</p><p><img src="/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640.png" alt="图片"></p><p>可以通过将多个交换机连接到一起，构建一个小型的网络。每个交换机中维护端口与MAC地址映射的表。</p><p><img src="/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640-20220728100853409.png" alt="图片"></p><img src="%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220728101042724.png" alt="image-20220728101042724" style="zoom:50%;" /><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p><strong>路由器的每个端口都具有独立的MAC地址</strong>，因此可以成为数据链路层的发送者和接收者。路由算法可以找到下一跳路由器，继而重复上述任务直到找到接收者ip。</p><p>路由器位于网络层，每个端口都具有独立的MAC地址，可以做数据的转发。</p><p><img src="/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/640-20220728103358215.png" alt="图片"></p><p>数据包格式：</p><p><img src="/2022/07/27/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.png"></p><ul><li><p>子网：位于同一交换机下的设备，数据包可以通过交换机发送，而不需要路由器的参与。</p></li><li><p>子网掩码：将源 IP 与目的 IP 分别同这个子网掩码进行<strong>与运算</strong>，相等则是在一个子网，不相等就是在不同子网。ip地址192.168.0.1，子网掩码为255.255.255.0，可可以表示为192.168.0.1&#x2F;24。前24bit相同的ip位于同一个子网中。</p></li><li><p>默认网关：即路由器的ip地址，设备以便在发给不同子网的机器时，发给默认网关的IP 地址，交由路由器转发数据包。</p></li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><blockquote><p><a href="https://www.cnblogs.com/cxuanBlog/p/14265315.html">https://www.cnblogs.com/cxuanBlog/p/14265315.html</a></p></blockquote><p>发送数据包的数据链路层需要知道 目标机器的MAC 地址，而实际上只知道目标的ip地址。</p><p><strong>ARP协议用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址</strong> 的一种协议。</p>]]></content>
    
    
    <categories>
      
      <category>“计算机网络”</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS IAM</title>
    <link href="/2022/07/06/AWS-IAM/"/>
    <url>/2022/07/06/AWS-IAM/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html">https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html</a></p></blockquote><p>**AWS Identity and Access Management (IAM)**：AWS身份认证和资源权限控制</p><p><strong>AWS account root user</strong>：根用户，拥有所有的AWS资源和服务的完全权限。类似于linux的root用户，不可以使用AWS根用户执行日常的操作。而是使用根用户去创建管理员用户和管理员用户组。使用管理员用户执行管理权限。</p><p>IAM的特性：</p><ul><li>共享AWS账户资源，不需要共享key或者密码</li><li>精细的资源权限控制：对于不同的IAM用户，授予不同的资源权限</li><li>IAM为AWS的application提供AWS资源的访问权限：robot用户</li><li><strong>联合身份</strong>：使用如google账户认证获取临时的credentials来访问某一个IAM user</li></ul><p><img src="/2022/07/06/AWS-IAM/image-20220707175842312.png" alt="image-20220707175842312"></p><h2 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h2><h3 id="1-IAM-Resources"><a href="#1-IAM-Resources" class="headerlink" title="1. IAM Resources"></a>1. IAM Resources</h3><p>IAM资源指IAM对象，包括 user, group, role, policy, and identity provider</p><p>identity provider：身份认证提供商，如GoogleApps。使用第三方的身份认证方式管理用户以及资源权限。</p><h3 id="2-IAM-Identities"><a href="#2-IAM-Identities" class="headerlink" title="2. IAM Identities"></a>2. IAM Identities</h3><p>包括users, groups, and roles。指可以赋予policy的IAM对象，用于身份鉴别以及分组。</p><h3 id="3-IAM-Entities"><a href="#3-IAM-Entities" class="headerlink" title="3. IAM Entities"></a>3. IAM Entities</h3><p>可用于鉴权的实体，如具体指 user，federated user（联合用户）和 assumed IAM roles</p><h3 id="4-Principals"><a href="#4-Principals" class="headerlink" title="4. Principals"></a>4. Principals</h3><p>是指利用 root 用户或 IAM user&#x2F;role 进行登录并请求（Request）使用 AWS 服务的<strong>个人或者应用</strong></p><h3 id="5-Authentication-and-Authorization"><a href="#5-Authentication-and-Authorization" class="headerlink" title="5. Authentication and Authorization"></a>5. Authentication and Authorization</h3><p>Authentication: 身份验证，指用户是否能够通过当前的credentials发送request</p><p>Authorization：授权，指当前的request是否有足够的权限执行。</p><h4 id="1-Attribute-based-access-control-ABAC"><a href="#1-Attribute-based-access-control-ABAC" class="headerlink" title="1. Attribute-based access control (ABAC)"></a>1. Attribute-based access control (ABAC)</h4><p>基于属性的访问控制，在role和resource的tag:value值相同时，允许访问该资源。增加权限时只需要修改资源的tag:value值。</p><h4 id="2-Role-based-access-control-RBAC"><a href="#2-Role-based-access-control-RBAC" class="headerlink" title="2. Role-based access control (RBAC)"></a>2. Role-based access control (RBAC)</h4><p>对不同的IAM identities赋予不同的policy，这叫基于角色的访问控制。若需要修改权限，则需要修改policy</p><h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h1><h2 id="1-users"><a href="#1-users" class="headerlink" title="1. users"></a>1. users</h2><p><strong>IAM users</strong>： 类似于linux系统中的用户，共享AWS账户资源，user也可以是application的robot用户，user也可以是管理员用户。可以通过创建IAM用户并分发credentials的方式分配账户。或者通过<strong>联合身份验证</strong>的方式，如G Suite SAML认证的方式，从AWS中获取临时的credentials。</p><p><strong>联合身份验证</strong>的方式通过google账户认证获取临时的credentials来访问某一个IAM</p><p><img src="/2022/07/06/AWS-IAM/image-20220707141821384.png" alt="image-20220707141821384"></p><h2 id="2-user-group"><a href="#2-user-group" class="headerlink" title="2. user group"></a>2. user group</h2><p>等同于linux的用户组概念。相同group的用户具有类似的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">aws iam create-group --group-name Admins<br>&#123;<br>    &quot;Group&quot;: &#123;<br>        &quot;Path&quot;: &quot;/&quot;, <br>        &quot;CreateDate&quot;: &quot;2014-06-05T20:29:53.622Z&quot;, <br>        &quot;GroupId&quot;:&quot;ABCDEFGHABCDEFGHABCDE&quot;,<br>        &quot;Arn&quot;: &quot;arn:aws:iam::123456789012:group/Admins&quot;, <br>        &quot;GroupName&quot;: &quot;Admins&quot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-policy"><a href="#3-policy" class="headerlink" title="3. policy"></a>3. policy</h2><p>policy定义了该用户组下所有的用户对AWS资源操作的权限，如AdministratorAccess管理员权限。policy可以被用户自定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws iam attach-group-policy --group-name Admins --policy-arn arn:aws:iam::aws:policy/AdministratorAccess<br></code></pre></td></tr></table></figure><p>policy在赋予用户组后可以继续被管理员更新，以增加或者减少资源权限。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FullAccessToSomeServices&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-string">&quot;ec2:*&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-string">&quot;s3:*&quot;</span><br>          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-string">&quot;iam:CreateServiceLinkedRole&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-string">&quot;iam:DeleteServiceLinkedRole&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-string">&quot;iam:ListRoles&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-string">&quot;organizations:DescribeOrganization&quot;</span><br>          <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dynamodb:*&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:dynamodb:us-east-2:123456789012:table/Books&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>policies中的permission决定了request是否能够被执行。</p><h2 id="4-role"><a href="#4-role" class="headerlink" title="4. role"></a>4. role</h2>]]></content>
    
    
    <categories>
      
      <category>AWS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS IAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS CDK</title>
    <link href="/2022/06/14/AWS-CDK/"/>
    <url>/2022/06/14/AWS-CDK/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://docs.aws.amazon.com/cdk/v2/guide/home.html">https://docs.aws.amazon.com/cdk/v2/guide/home.html</a></p></blockquote><p><em>AWS Cloud Development Kit (CDK)</em> 使用<strong>代码定义云基础设施</strong>，通过生成AWS CloudFormation模版部署云服务。可以把CDK看作是CloudFormation的上层包装，CDK最终会生成CloudFormation模版。</p><p>基础设施、应用代码以及配置等均可以使用代码来管理。CDK可以很好的将AWS service整合起来。可复用service已有的AWS CloudFormation templates。</p><p>CDK是用于搭建基础设施的代码，具体的应用代码可以用调用SDK实现。CDK搭建基础设施后，可以由SDK进行调用。</p><h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h1><img src="AWS-CDK/AppStacks.png" alt="img" style="zoom:80%;" /><h2 id="1-Constructs"><a href="#1-Constructs" class="headerlink" title="1. Constructs"></a>1. Constructs</h2><p>Constructs是AWS CDK apps基础的building block。最基础的云组件，可以是单个AWS 资源，也可以是多个AWS资源的高级抽象。</p><p>一个Stack由多个Constructs构成，一个app可以由多个Stack构成。</p><p>L1 Constructs: CloudFormation原生支持，必须配置资源的所有properties</p><figure class="highlight dns"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dns">CfnBucket  <span class="hljs-keyword">A</span> CloudFormation AWS<span class="hljs-number">::</span>S<span class="hljs-number">3::</span>Bucket.<br></code></pre></td></tr></table></figure><p>L2 Constructs: L1的高层封装，提供默认值以及逻辑封装</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Bucket </span> An <span class="hljs-built_in">S3</span> <span class="hljs-keyword">bucket </span>with associated policy objects.<br></code></pre></td></tr></table></figure><p>L3 constructs: 特殊用法，通常是为了完成相似类型的任务，具有少量的参数接口</p><p>Constructs是一种层级的结构<em>construct tree</em>，高等级的Constructs可以由低等级的Constructs组合而成。如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotifyingBucket</span>(<span class="hljs-title class_ inherited__">Construct</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, scope: Construct, <span class="hljs-built_in">id</span>: <span class="hljs-built_in">str</span>, *, prefix=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__(scope, <span class="hljs-built_in">id</span>)<br>        bucket = s3.Bucket(self, <span class="hljs-string">&quot;bucket&quot;</span>)<br>        topic = sns.Topic(self, <span class="hljs-string">&quot;topic&quot;</span>)<br>        bucket.add_object_created_notification(s3notify.SnsDestination(topic),<br>            s3.NotificationKeyFilter(prefix=prefix))<br>  <br></code></pre></td></tr></table></figure><p>Constructs具有</p><ul><li><strong>scope</strong>：Constructs的父层级</li><li><strong>id</strong>：Constructs标识符</li><li><strong>props</strong>：Constructs的配置参数</li></ul><h1 id="3-流程"><a href="#3-流程" class="headerlink" title="3. 流程"></a>3. 流程</h1><blockquote><p><a href="https://docs.aws.amazon.com/cdk/v2/guide/hello_world.html">https://docs.aws.amazon.com/cdk/v2/guide/hello_world.html</a></p><p><a href="https://github.com/WeiYUN13/blog_examples/tree/master/hello-cdk">https://github.com/WeiYUN13/blog_examples/tree/master/hello-cdk</a></p></blockquote><h2 id="1-创建app"><a href="#1-创建app" class="headerlink" title="1. 创建app"></a>1. 创建app</h2><p>CDK project依赖local的module</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir hello-cdk<br>cd hello-cdk<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用app模版初始化CDK project</span><br>cdk init app --language python<br>&lt;&lt;&#x27;COMMENT&#x27;<br>╭─noname@yunwei ~/Desktop/work/hello-cdk ‹master› <br>╰─$ tree                    <br>.<br>├── README.md<br>├── app.py<br>├── cdk.json<br>├── hello_cdk<br>│   ├── __init__.py<br>│   └── hello_cdk_stack.py<br>├── requirements-dev.txt<br>├── requirements.txt<br>├── source.bat<br>└── tests<br>    ├── __init__.py<br>    └── unit<br>        ├── __init__.py<br>        └── test_hello_cdk_stack.py<br><br>3 directories, 11 files<br>COMMENT<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用venv安装requirements</span><br>source .venv/bin/activate<br>python -m pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h2 id="2-添加s3-buckets"><a href="#2-添加s3-buckets" class="headerlink" title="2. 添加s3 buckets"></a>2. 添加s3 buckets</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aws_cdk <span class="hljs-keyword">as</span> cdk<br><span class="hljs-keyword">import</span> aws_cdk.aws_s3 <span class="hljs-keyword">as</span> s3<br>            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloCdkStack</span>(cdk.Stack):<br><br>    <span class="hljs-comment"># 此处的scope是定义当前stack的parent</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, scope: cdk.App, construct_id: <span class="hljs-built_in">str</span>, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__(scope, construct_id, **kwargs)<br><span class="hljs-comment"># 定义scope，self表示当前的stack，构建元素间的层级关系</span><br>        <span class="hljs-comment"># id表示逻辑ID，不是bucket name， bucket_name由cloudFormation指定</span><br>        <span class="hljs-comment"># versioned启用版本控制</span><br>        bucket = s3.Bucket(self, <span class="hljs-string">&quot;MyFirstBucket&quot;</span>, versioned=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="3-生成CloudFormation-templates"><a href="#3-生成CloudFormation-templates" class="headerlink" title="3. 生成CloudFormation templates"></a>3. 生成CloudFormation templates</h2><p>Run <code>cdk synth</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;Resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;MyFirstBucketB8884501&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;Type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AWS::S3::Bucket&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;Properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;VersioningConfiguration&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;Status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Enabled&quot;</span> # 启动版本控制<br>    <span class="hljs-punctuation">&#125;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;UpdateReplacePolicy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Retain&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;DeletionPolicy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Retain&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;Metadata&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;aws:cdk:path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HelloCdkStack/MyFirstBucket/Resource&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置aws region以及profile， 默认profile为default</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[default]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">region=us-west-2</span><br>export AWS_PROFILE=sts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">deploy前会自动synth</span><br>cdk deploy<br></code></pre></td></tr></table></figure><p><code>cdk bootstrap</code> Deploys the CDK toolkit stack into an AWS environment</p><p>CDK引导程序，AWS CloudFormation部署所需的外部文件，需要使用引导程序预先保存到AWS S3 bucket中。</p><p>CDKToolkit stack保存各种AWS CDK所需资源，比如保存app的CloudFormation的template json至S3中。</p><img src="AWS-CDK/image-20220615152108151.png" alt="image-20220615152108151" style="zoom:80%;" /><p><strong>Stack</strong>是AWS CDK部署的基本单元：也就是CDK按单个Stack进行部署。</p><h2 id="5-更新"><a href="#5-更新" class="headerlink" title="5. 更新"></a>5. 更新</h2><p>CDK通过CloudFormation的changeset，更新app。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bucket = s3.Bucket(self, <span class="hljs-string">&quot;MyFirstBucket&quot;</span>,<br>    versioned=<span class="hljs-literal">True</span>,<br>    removal_policy=cdk.RemovalPolicy.DESTROY, <span class="hljs-comment"># stack摧毁时自动删除bucket</span><br>    auto_delete_objects=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 自动删除bucket的对象</span><br></code></pre></td></tr></table></figure><p><code>cdk diff</code>查看diff</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs txt">╰─$ cdk diff            <br>Stack HelloCdkStack<br>IAM Statement Changes<br>┌───┬───────────────────────────────────────────────────────────────┬────────┬───────────────────────────────────────┬───────────────────────────────────────────────────────────────────┬───────────┐<br>│   │ Resource                                                      │ Effect │ Action                                │ Principal                                                         │ Condition │<br>├───┼───────────────────────────────────────────────────────────────┼────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────┼───────────┤<br>│ + │ $&#123;Custom::S3AutoDeleteObjectsCustomResourceProvider/Role.Arn&#125; │ Allow  │ sts:AssumeRole                        │ Service:lambda.amazonaws.com                                      │           │<br>├───┼───────────────────────────────────────────────────────────────┼────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────┼───────────┤<br>│ + │ $&#123;MyFirstBucket.Arn&#125;                                          │ Allow  │ s3:DeleteObject*                      │ AWS:$&#123;Custom::S3AutoDeleteObjectsCustomResourceProvider/Role.Arn&#125; │           │<br>│   │ $&#123;MyFirstBucket.Arn&#125;/*                                        │        │ s3:GetBucket*                         │                                                                   │           │<br>│   │                                                               │        │ s3:List*                              │                                                                   │           │<br>└───┴───────────────────────────────────────────────────────────────┴────────┴───────────────────────────────────────┴───────────────────────────────────────────────────────────────────┴───────────┘<br>IAM Policy Changes<br>┌───┬───────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────────┐<br>│   │ Resource                                                  │ Managed Policy ARN                                                                           │<br>├───┼───────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤<br>│ + │ $&#123;Custom::S3AutoDeleteObjectsCustomResourceProvider/Role&#125; │ &#123;&quot;Fn::Sub&quot;:&quot;arn:$&#123;AWS::Partition&#125;:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole&quot;&#125; │<br>└───┴───────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────────┘<br>(NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299)<br><br>Resources<br>[+] AWS::S3::BucketPolicy MyFirstBucket/Policy MyFirstBucketPolicy3243DEFD <br>[+] Custom::S3AutoDeleteObjects MyFirstBucket/AutoDeleteObjectsCustomResource MyFirstBucketAutoDeleteObjectsCustomResourceC52FCF6E <br>[+] AWS::IAM::Role Custom::S3AutoDeleteObjectsCustomResourceProvider/Role CustomS3AutoDeleteObjectsCustomResourceProviderRole3B1BD092 <br>[+] AWS::Lambda::Function Custom::S3AutoDeleteObjectsCustomResourceProvider/Handler CustomS3AutoDeleteObjectsCustomResourceProviderHandler9D90184F <br>[~] AWS::S3::Bucket MyFirstBucket MyFirstBucketB8884501 <br> ├─ [+] Tags<br> │   └─ [&#123;&quot;Key&quot;:&quot;aws-cdk:auto-delete-objects&quot;,&quot;Value&quot;:&quot;true&quot;&#125;]<br> ├─ [~] DeletionPolicy<br> │   ├─ [-] Retain<br> │   └─ [+] Delete<br> └─ [~] UpdateReplacePolicy<br>     ├─ [-] Retain<br>     └─ [+] Delete<br></code></pre></td></tr></table></figure><p><code>cdk deploy</code>重新部署此更新</p><p><img src="/2022/06/14/AWS-CDK/image-20220615155214976.png"></p><p>由于新的destroy policy的引入，Stack资源加入了更多的component，比如用于删除S3 objects的lambda函数<code>CustomS3AutoDeleteObjectsCustomResourceProviderHandler9D90184F</code></p><h2 id="6-销毁"><a href="#6-销毁" class="headerlink" title="6. 销毁"></a>6. 销毁</h2><p><code>cdk destroy</code> 快速销毁CDK创建的AWS资源</p><p>部分资源需要配置<code>RemovalPolicy</code>以定制destroy时采取的策略。</p><h1 id="4-python开发"><a href="#4-python开发" class="headerlink" title="4. python开发"></a>4. python开发</h1><blockquote><p><a href="https://github.com/aws-samples/aws-cdk-examples">https://github.com/aws-samples/aws-cdk-examples</a></p></blockquote><h2 id="1-AWS-Construct-Library"><a href="#1-AWS-Construct-Library" class="headerlink" title="1. AWS Construct Library"></a>1. AWS Construct Library</h2><blockquote><p><a href="https://docs.aws.amazon.com/cdk/api/v2/python/index.html">https://docs.aws.amazon.com/cdk/api/v2/python/index.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install aws-cdk-lib<br>import aws_cdk as cdk<br></code></pre></td></tr></table></figure><h2 id="2-AWS-CLI"><a href="#2-AWS-CLI" class="headerlink" title="2. AWS CLI"></a>2. AWS CLI</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g aws-cdk<br></code></pre></td></tr></table></figure><h2 id="3-s3-trigger-lambda"><a href="#3-s3-trigger-lambda" class="headerlink" title="3. s3 trigger lambda"></a>3. s3 trigger lambda</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lambda_handler.py</span><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> urllib.parse<br><span class="hljs-keyword">import</span> boto3<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Loading function&#x27;</span>)<br><br>s3 = boto3.client(<span class="hljs-string">&#x27;s3&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lambda_handler</span>(<span class="hljs-params">event, context</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received event: &quot;</span> + json.dumps(event, indent=<span class="hljs-number">2</span>))<br><br>    <span class="hljs-comment"># Get the object from the event and show its content type</span><br>    bucket = event[<span class="hljs-string">&#x27;Records&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;s3&#x27;</span>][<span class="hljs-string">&#x27;bucket&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    key = urllib.parse.unquote_plus(<br>        event[<span class="hljs-string">&#x27;Records&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;s3&#x27;</span>][<span class="hljs-string">&#x27;object&#x27;</span>][<span class="hljs-string">&#x27;key&#x27;</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    response = s3.get_object(Bucket=bucket, Key=key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CONTENT TYPE: &quot;</span> + response[<span class="hljs-string">&#x27;ContentType&#x27;</span>])<br>    <span class="hljs-built_in">print</span>(response.get()[<span class="hljs-string">&#x27;Body&#x27;</span>].read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">return</span> response[<span class="hljs-string">&#x27;ContentType&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aws_cdk <span class="hljs-keyword">import</span> (<br>    aws_lambda <span class="hljs-keyword">as</span> lambda_,<br>    Stack,<br>    aws_s3 <span class="hljs-keyword">as</span> s3,<br>    aws_s3_notifications,<br>)<br><span class="hljs-keyword">from</span> constructs <span class="hljs-keyword">import</span> Construct<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">S3TriggerLambdaStack</span>(<span class="hljs-title class_ inherited__">Stack</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, scope: Construct, construct_id: <span class="hljs-built_in">str</span>, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__(scope, construct_id, **kwargs)<br><br>        <span class="hljs-comment"># create lambda function</span><br>        function = lambda_.Function(self, <span class="hljs-string">&quot;lambda_function_example&quot;</span>,<br>                                    runtime=lambda_.Runtime.PYTHON_3_9,<br>                                    handler=<span class="hljs-string">&quot;lambda_handler.lambda_handler&quot;</span>,<br>                                    code=lambda_.Code.from_asset(<span class="hljs-string">&quot;./lambda&quot;</span>))<br><br>        <span class="hljs-comment"># create s3 buckets</span><br>        s3_bucket = s3.Bucket(self, <span class="hljs-string">&quot;my_s3_bucket&quot;</span>)<br><br>        <span class="hljs-comment"># s3_bucket授予lambda读权限</span><br>        s3_bucket.grant_read(function)<br>        <br>        <span class="hljs-comment"># s3 notification to lambda function</span><br>        notification = aws_s3_notifications.LambdaDestination(function)<br><br>        <span class="hljs-comment"># send notification after event</span><br>        s3_bucket.add_event_notification(s3.EventType.OBJECT_CREATED, notification)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AWS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS CDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS lambda</title>
    <link href="/2022/06/13/AWS-lambda/"/>
    <url>/2022/06/13/AWS-lambda/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html">https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html</a></p></blockquote><p>AWS lambda可以在无需管理服务器以及计算资源的情况下运行代码，典型的<strong>无服务架构</strong>。同时提供了动态伸缩、高可用的计算资源。无服务的一大好处是计算资源完全托管，无需用户管理，只需要按调用次数付费即可。用户可以更加专注于自己的代码。</p><p>AWS lambda可作为AWS服务之间的关联方式，使用lambda作为AWS服务之间交互，定义交互的代码逻辑。</p><h2 id="1-部署方式"><a href="#1-部署方式" class="headerlink" title="1. 部署方式"></a>1. 部署方式</h2><ul><li>压缩源代码文件zip，包含所有源代码以及依赖。lambda支持多种主流语言的运行时。</li><li>容器镜像，如docker image等符合OCI标准的镜像。image会被存储到Amazon ECR</li></ul><h2 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2. 配置方式"></a>2. 配置方式</h2><ul><li>浏览器的Lambda console</li><li>AWS CLI</li><li>AWS SDK or CDK</li></ul><p>example:</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lambda function</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lambda_handler</span>(<span class="hljs-params">event, context</span>):<br>    <span class="hljs-built_in">print</span>(event)<br>    <span class="hljs-built_in">print</span>(context)<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&#x27;statusCode&#x27;</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-string">&#x27;body&#x27;</span>: json.dumps(<span class="hljs-string">&#x27;Hello from Lambda!&#x27;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs txt">Test Event Name<br>test<br><br>Response<br>&#123;<br>  &quot;statusCode&quot;: 200,<br>  &quot;body&quot;: &quot;\&quot;Hello from Lambda!\&quot;&quot;<br>&#125;<br><br>Function Logs<br>START RequestId: 2d074e33-51bf-4176-8d08-782700ffae62 Version: $LATEST<br>&#123;&#x27;hello&#x27;: &#x27;hello&#x27;, &#x27;name&#x27;: &#x27;jack&#x27;, &#x27;other&#x27;: &#x27;rose&#x27;&#125;<br>LambdaContext([aws_request_id=2d074e33-51bf-4176-8d08-782700ffae62,log_group_name=/aws/lambda/test_lambda,log_stream_name=2022/06/14/[$LATEST]f5bfdd9530b44cd091ed19ac7b172ab4,function_name=test_lambda,memory_limit_in_mb=128,function_version=$LATEST,invoked_function_arn=arn:aws:lambda:us-west-2:061479767641:function:test_lambda,client_context=None,identity=CognitoIdentity([cognito_identity_id=None,cognito_identity_pool_id=None])])<br>END RequestId: 2d074e33-51bf-4176-8d08-782700ffae62<br>REPORT RequestId: 2d074e33-51bf-4176-8d08-782700ffae62Duration: 0.93 msBilled Duration: 1 msMemory Size: 128 MBMax Memory Used: 35 MB<br><br>Request ID<br>2d074e33-51bf-4176-8d08-782700ffae62<br></code></pre></td></tr></table></figure><h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h1><p>以s3和aws lambda交互为例</p><h2 id="1-function"><a href="#1-function" class="headerlink" title="1. function"></a>1. function</h2><p>lambda函数的处理逻辑。event可以手动传入invoke或者是由其他的AWS服务发送给lambda函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> urllib.parse<br><span class="hljs-keyword">import</span> boto3<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Loading function&#x27;</span>)<br><br>s3 = boto3.client(<span class="hljs-string">&#x27;s3&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lambda_handler</span>(<span class="hljs-params">event, context</span>):<br>    <span class="hljs-comment">#print(&quot;Received event: &quot; + json.dumps(event, indent=2))</span><br><br>    <span class="hljs-comment"># Get the object from the event and show its content type</span><br>    bucket = event[<span class="hljs-string">&#x27;Records&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;s3&#x27;</span>][<span class="hljs-string">&#x27;bucket&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]<br>    key = urllib.parse.unquote_plus(event[<span class="hljs-string">&#x27;Records&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;s3&#x27;</span>][<span class="hljs-string">&#x27;object&#x27;</span>][<span class="hljs-string">&#x27;key&#x27;</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        response = s3.get_object(Bucket=bucket, Key=key)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CONTENT TYPE: &quot;</span> + response[<span class="hljs-string">&#x27;ContentType&#x27;</span>])<br>        <span class="hljs-keyword">return</span> response[<span class="hljs-string">&#x27;ContentType&#x27;</span>]<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(e)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error getting object &#123;&#125; from bucket &#123;&#125;. Make sure they exist and your bucket is in the same region as this function.&#x27;</span>.<span class="hljs-built_in">format</span>(key, bucket))<br>        <span class="hljs-keyword">raise</span> e<br></code></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><blockquote><p><a href="https://docs.aws.amazon.com/lambda/latest/dg/python-handler.html">https://docs.aws.amazon.com/lambda/latest/dg/python-handler.html</a></p></blockquote><p>function返回值的处理，取决于lambda的调用类型以及触发lambda服务的类型。</p><h2 id="2-trigger"><a href="#2-trigger" class="headerlink" title="2. trigger"></a>2. trigger</h2><p>lambda函数的触发器，可以是被某些AWS服务所触发。如由s3 bucket对象创建触发:</p><p>⚠️ lambda函数如果被s3触发后，行为是写入同一个s3中，可能回导致递归的函数触发，造成严重的结果。</p><p><img src="/2022/06/13/AWS-lambda/image-20220614155236190.png" alt="image-20220614155236190"></p><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><h3 id="1-同步触发-synchronous-invocation"><a href="#1-同步触发-synchronous-invocation" class="headerlink" title="1. 同步触发 synchronous invocation"></a>1. 同步触发 <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-sync.html">synchronous invocation</a></h3><p>触发lambda函数并等待其返回结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; response.json<br></code></pre></td></tr></table></figure><p>查询lambda函数的log</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws lambda invoke --function-name my-function out --log-type Tail --query &#x27;LogResult&#x27; --output text |  base64 -d<br></code></pre></td></tr></table></figure><h3 id="2-异步触发-asynchronous-invocation"><a href="#2-异步触发-asynchronous-invocation" class="headerlink" title="2. 异步触发 asynchronous invocation"></a>2. 异步触发 <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html">asynchronous invocation</a></h3><p>Lambda将event放置到队列中并立刻返回成功消息。一个额外的进程会读取队列中的event并发送给lambda函数执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws lambda invoke --function-name my-function  --invocation-type Event --cli-binary-format raw-in-base64-out --payload &#x27;&#123; &quot;key&quot;: &quot;value&quot; &#125;&#x27; response.json<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--invocation-type Event 异步触发</span><br></code></pre></td></tr></table></figure><h2 id="3-event"><a href="#3-event" class="headerlink" title="3. event"></a>3. event</h2><p>传递给function的参数，形式是一个json字典(手动触发时，event可以是任何的数据结构)。由AWS service触发时，event的的格式基本为json，具体参数取决于service类型。</p><p>不同的AWS service的<a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-services.html">event json格式</a>各不相同，如<a href="https://docs.aws.amazon.com/lambda/latest/dg/with-s3.html">s3触发的json格式</a>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Records&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;eventVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;eventSource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;aws:s3&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;awsRegion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;us-east-1&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;eventTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1970-01-01T00:00:00.000Z&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;eventName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ObjectCreated:Put&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;userIdentity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;principalId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;EXAMPLE&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;requestParameters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;sourceIPAddress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;responseElements&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;x-amz-request-id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;EXAMPLE123456789&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;x-amz-id-2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;EXAMPLE123/5678abcdefghijklambdaisawesome/mnopqrstuvwxyzABCDEFGH&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;s3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;s3SchemaVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;configurationId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;testConfigRule&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;bucket&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-test-bucket&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;ownerIdentity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;principalId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;EXAMPLE&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;arn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;object&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;content&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1024</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;eTag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0123456789abcdef0123456789abcdef&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;sequencer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0A1B2C3D4E5F678901&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>bucket不存在时，使用上述event触发lambda的response：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs txt">Test Event Name<br>test<br><br>Response<br>&#123;<br>  &quot;errorMessage&quot;: &quot;An error occurred (AccessDenied) when calling the GetObject operation: Access Denied&quot;,<br>  &quot;errorType&quot;: &quot;ClientError&quot;,<br>  &quot;stackTrace&quot;: [<br>    &quot;  File \&quot;/var/task/lambda_function.py\&quot;, line 23, in lambda_handler\n    raise e\n&quot;,<br>    &quot;  File \&quot;/var/task/lambda_function.py\&quot;, line 17, in lambda_handler\n    response = s3.get_object(Bucket=bucket, Key=key)\n&quot;,<br>    &quot;  File \&quot;/var/runtime/botocore/client.py\&quot;, line 391, in _api_call\n    return self._make_api_call(operation_name, kwargs)\n&quot;,<br>    &quot;  File \&quot;/var/runtime/botocore/client.py\&quot;, line 719, in _make_api_call\n    raise error_class(parsed_response, operation_name)\n&quot;<br>  ]<br>&#125;<br><br>Function Logs<br>START RequestId: d2b2a1b0-db50-49d4-acf8-41e58ce880c3 Version: $LATEST<br>An error occurred (AccessDenied) when calling the GetObject operation: Access Denied<br>Error getting object content from bucket my-test-bucket. Make sure they exist and your bucket is in the same region as this function.<br>[ERROR] ClientError: An error occurred (AccessDenied) when calling the GetObject operation: Access Denied<br>Traceback (most recent call last):<br>  File &quot;/var/task/lambda_function.py&quot;, line 23, in lambda_handler<br>    raise e<br>  File &quot;/var/task/lambda_function.py&quot;, line 17, in lambda_handler<br>    response = s3.get_object(Bucket=bucket, Key=key)<br>  File &quot;/var/runtime/botocore/client.py&quot;, line 391, in _api_call<br>    return self._make_api_call(operation_name, kwargs)<br>  File &quot;/var/runtime/botocore/client.py&quot;, line 719, in _make_api_call<br>    raise error_class(parsed_response, operation_name)<br>END RequestId: d2b2a1b0-db50-49d4-acf8-41e58ce880c3<br>REPORT RequestId: d2b2a1b0-db50-49d4-acf8-41e58ce880c3Duration: 966.62 msBilled Duration: 967 msMemory Size: 128 MBMax Memory Used: 71 MBInit Duration: 452.77 ms<br><br>Request ID<br>d2b2a1b0-db50-49d4-acf8-41e58ce880c3<br></code></pre></td></tr></table></figure><h1 id="3-权限配置"><a href="#3-权限配置" class="headerlink" title="3. 权限配置"></a>3. 权限配置</h1><p><strong>执行角色 execution role</strong>：可以为lambda函数配置execution role。使用execution role可以在lambda函数内部访问该role可以访问到的aws资源。</p>]]></content>
    
    
    <categories>
      
      <category>AWS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS CodeBuild</title>
    <link href="/2022/06/08/AWS-CodeBuild/"/>
    <url>/2022/06/08/AWS-CodeBuild/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html">https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html</a></p></blockquote><p>CodeBuild是完全托管到AWS的云构建服务。无需管理build server，按需扩容以满足峰值构建需求，预先配置的构建环境。也可用于持续集成和持续交付。</p><blockquote><p>AWS CodeBuild 是一项在云中完全托管的生成服务。CodeBuild 可编译源代码，运行单元测试，并生成可供部署的构件。使用 CodeBuild，您无需预配置、管理和扩展自己的构建服务器。它提供了适用于常用编程语言的预先打包的构建环境以及 Apache Maven 和 Gradle 等构建工具。您还可以在 CodeBuild 中自定义构建环境以使用自己的构建工具。CodeBuild 会自动扩展以满足峰值构建请求。</p></blockquote><p>CodeBuild使用<strong>buildspec.yaml</strong>来运行构建任务，类似于github CI的workflow配置。<strong>buildspec</strong>包含各种构建的配置以及命令。</p><blockquote><p><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html">https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html</a></p></blockquote><p>CodeBuild属于CodePipeline build和test服务。</p><h1 id="2-buildspec"><a href="#2-buildspec" class="headerlink" title="2. buildspec"></a>2. buildspec</h1><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-number">0.2</span><br><br><span class="hljs-attr">phases:</span><br>  <span class="hljs-attr">install:</span><br>    <span class="hljs-attr">runtime-versions:</span><br>      <span class="hljs-attr">java:</span> <span class="hljs-string">corretto11</span><br>  <span class="hljs-attr">pre_build:</span><br>    <span class="hljs-attr">commands:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">Nothing</span> <span class="hljs-string">to</span> <span class="hljs-string">do</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">pre_build</span> <span class="hljs-string">phase...</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">commands:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">Build</span> <span class="hljs-string">started</span> <span class="hljs-string">on</span> <span class="hljs-string">`date`</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">install</span><br>  <span class="hljs-attr">post_build:</span><br>    <span class="hljs-attr">commands:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">Build</span> <span class="hljs-string">completed</span> <span class="hljs-string">on</span> <span class="hljs-string">`date`</span><br><span class="hljs-attr">artifacts:</span><br>  <span class="hljs-attr">files:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">target/messageUtil-1.0.jar</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://docs.aws.amazon.com/codebuild/latest/userguide/getting-started-cli-create-build-project.html">https://docs.aws.amazon.com/codebuild/latest/userguide/getting-started-cli-create-build-project.html</a></p></blockquote><p>AWS cli配置build project的相关信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置运行环境以及源代码位置以及输出的路径等</span><br>aws codebuild create-project --generate-cli-skeleton<br>aws codebuild create-project --cli-input-json file://create-project.json<br></code></pre></td></tr></table></figure><p>Run build</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws codebuild start-build --project-name project-name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AWS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS CodeBuild</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS Basics</title>
    <link href="/2022/06/08/AWS-Basics/"/>
    <url>/2022/06/08/AWS-Basics/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>AWS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS basics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS CloudFormation</title>
    <link href="/2022/06/07/AWS-CloudFormation/"/>
    <url>/2022/06/07/AWS-CloudFormation/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html">https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html</a></p><p><a href="https://1c7.me/aws-cloudformation-tutorial-in-chinese/">https://1c7.me/aws-cloudformation-tutorial-in-chinese/</a></p></blockquote><p>CloudFormation是AWS对<strong>Infrastructure as Code</strong> (IaC)基础设施即代码的实现。把要用的AWS资源，写成模板文件，方便复用和追踪版本变更。</p><p>CloudFormation用<strong>配置文件搭建和管理AWS资源</strong>，简化对基础设施的管理，可以将一组AWS资源作为一个单独的单元进行管理。资源配置完全是用配置文件实现的，因此可以对配置文件做版本管理，回退以及更新都十分简单。</p><p>CloudFormation负责创建和管理资源，对资源的后续具体操作，与CloudFormation无关。CloudFormation可以在销毁AWS资源的时候使用<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html"><strong>DeletionPolicy</strong></a>保留部分资源。</p><h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h1><h2 id="1-templates"><a href="#1-templates" class="headerlink" title="1. templates"></a>1. templates</h2><blockquote><p><a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html">https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html</a></p></blockquote><p>模版定义了AWS的资源以及特性，定义在配置文件中。CloudFormation通过调用底层的AWS服务来配置资源。每个template定义一个stack，单个stack中可以包含多种不同的AWS资源。</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">AWSTemplateFormatVersion:</span> <span class="hljs-number">2010-09-09</span><br><span class="hljs-attr">Description:</span> <span class="hljs-string">A</span> <span class="hljs-string">sample</span> <span class="hljs-string">template</span><br><span class="hljs-attr">Resources:</span><br>  <span class="hljs-attr">MyEC2Instance:</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">&#x27;AWS::EC2::Instance&#x27;</span><br>    <span class="hljs-attr">Properties:</span><br>      <span class="hljs-attr">ImageId:</span> <span class="hljs-string">ami-0ff8a91507f77f867</span> <span class="hljs-comment"># software配置名，用于配置EC2 Instance</span><br>      <span class="hljs-attr">InstanceType:</span> <span class="hljs-string">t2.micro</span> <span class="hljs-comment"># https://aws.amazon.com/cn/ec2/instance-types/t2/</span><br>      <span class="hljs-attr">KeyName:</span> <span class="hljs-string">testkey</span><br>      <span class="hljs-attr">BlockDeviceMappings:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">DeviceName:</span> <span class="hljs-string">/dev/sdm</span><br>          <span class="hljs-attr">Ebs:</span><br>            <span class="hljs-attr">VolumeType:</span> <span class="hljs-string">io1</span><br>            <span class="hljs-attr">Iops:</span> <span class="hljs-number">200</span><br>            <span class="hljs-attr">DeleteOnTermination:</span> <span class="hljs-literal">false</span><br>            <span class="hljs-attr">VolumeSize:</span> <span class="hljs-number">20</span><br>  <span class="hljs-attr">MyEIP:</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">&#x27;AWS::EC2::EIP&#x27;</span><br>    <span class="hljs-attr">Properties:</span><br>      <span class="hljs-attr">InstanceId:</span> <span class="hljs-type">!Ref</span> <span class="hljs-string">MyEC2Instance</span><br></code></pre></td></tr></table></figure><p><a href="https://console.aws.amazon.com/cloudformation/designer"><strong>AWS CloudFormation Designer</strong></a>使用图形界面编辑并生成templates.</p><h2 id="2-Stacks"><a href="#2-Stacks" class="headerlink" title="2. Stacks"></a>2. Stacks</h2><p>CloudFormation通过template配置和管理的资源集合称为<strong>stack</strong></p><blockquote><p>A stack is a collection of AWS resources that you can manage as a single unit. In other words, you can create, update, or delete a collection of resources by creating, updating, or deleting stacks. All the resources in a stack are defined by the stack’s AWS CloudFormation template. A stack, for instance, can include all the resources required to run a web application, such as a web server, a database, and networking rules. If you no longer require that web application, you can simply delete the stack, and all of its related resources are deleted.</p></blockquote><h2 id="3-Change-sets"><a href="#3-Change-sets" class="headerlink" title="3. Change sets"></a>3. Change sets</h2><p>change sets用来更新stacks，将修改后的templates和原始的templates对比生成change sets。应用至Stacks。Change sets反应了即将进行的更新对各种stack资源的修改。</p><blockquote><p>When you need to update your stack’s resources, you can modify the stack’s template. You don’t need to create a new stack and delete the old one. To update a stack, create a change set by submitting a modified version of the original stack template, different input parameter values, or both. CloudFormation compares the modified template with the original template and generates a change set. The change set lists the proposed changes.</p></blockquote><h1 id="3-Getting-started"><a href="#3-Getting-started" class="headerlink" title="3. Getting started"></a>3. Getting started</h1><blockquote><p><a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/GettingStarted.Walkthrough.html">https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/GettingStarted.Walkthrough.html</a></p><p><a href="https://s3.us-west-2.amazonaws.com/cloudformation-templates-us-west-2/WordPress_Single_Instance.template">https://s3.us-west-2.amazonaws.com/cloudformation-templates-us-west-2/WordPress_Single_Instance.template</a></p></blockquote><h2 id="1-template参数化"><a href="#1-template参数化" class="headerlink" title="1. template参数化"></a>1. template参数化</h2><p>CloudFormation支持向template中传入参数，可以在创建stack的时候定制stack</p><h2 id="2-template存储"><a href="#2-template存储" class="headerlink" title="2. template存储"></a>2. template存储</h2><p>template可以存储至本地或者S3。</p><p>在使用template创建stack时，CloudFormation会将templates存储至对应region的S3特定bucket中。</p><p><img src="/2022/06/07/AWS-CloudFormation/image-20220729110253282.png" alt="image-20220729110253282"></p><h2 id="3-template基础"><a href="#3-template基础" class="headerlink" title="3. template基础"></a>3. template基础</h2><blockquote><p>常见函数：<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html">https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html</a></p></blockquote><h3 id="1-Resources"><a href="#1-Resources" class="headerlink" title="1. Resources"></a>1. Resources</h3><p>AWS资源的配置以及相互关联</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Parameters:</span><br>  <span class="hljs-attr">KeyName:</span><br>    <span class="hljs-attr">Description:</span> <span class="hljs-string">The</span> <span class="hljs-string">EC2</span> <span class="hljs-string">Key</span> <span class="hljs-string">Pair</span> <span class="hljs-string">to</span> <span class="hljs-string">allow</span> <span class="hljs-string">SSH</span> <span class="hljs-string">access</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">instance</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">&#x27;AWS::EC2::KeyPair::KeyName&#x27;</span><br><span class="hljs-attr">Resources:</span><br>  <span class="hljs-attr">Ec2Instance:</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">&#x27;AWS::EC2::Instance&#x27;</span> <span class="hljs-comment"># 资源类型</span><br>    <span class="hljs-attr">Properties:</span> <span class="hljs-comment"># 定义资源的Properties，可用默认值</span><br>      <span class="hljs-attr">SecurityGroups:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-type">!Ref</span> <span class="hljs-string">InstanceSecurityGroup</span>  <span class="hljs-comment"># ref函数指向另外一个资源</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">MyExistingSecurityGroup</span><br>      <span class="hljs-attr">KeyName:</span> <span class="hljs-type">!Ref</span> <span class="hljs-string">KeyName</span>  <span class="hljs-comment"># ref函数指向Parameters</span><br>      <span class="hljs-attr">ImageId:</span> <span class="hljs-string">ami-7a11e213</span><br>  <span class="hljs-attr">InstanceSecurityGroup:</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">&#x27;AWS::EC2::SecurityGroup&#x27;</span><br>    <span class="hljs-attr">Properties:</span><br>      <span class="hljs-attr">GroupDescription:</span> <span class="hljs-string">Enable</span> <span class="hljs-string">SSH</span> <span class="hljs-string">access</span> <span class="hljs-string">via</span> <span class="hljs-string">port</span> <span class="hljs-number">22</span><br>      <span class="hljs-attr">SecurityGroupIngress:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">IpProtocol:</span> <span class="hljs-string">tcp</span><br>          <span class="hljs-attr">FromPort:</span> <span class="hljs-number">22</span><br>          <span class="hljs-attr">ToPort:</span> <span class="hljs-number">22</span><br>          <span class="hljs-attr">CidrIp:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/0</span><br></code></pre></td></tr></table></figure><h3 id="2-Parameters"><a href="#2-Parameters" class="headerlink" title="2. Parameters"></a>2. Parameters</h3><p>定义输入参数的特性以及限制（用于验证输入是否合法），Parameters可以被后续的Resources等引用。</p><p>无默认值的参数必须指定，如KeyName，有默认值的参数未指定时使用默认参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Parameters:</span><br>  <span class="hljs-attr">KeyName:</span><br>    <span class="hljs-attr">Description:</span> <span class="hljs-string">Name</span> <span class="hljs-string">of</span> <span class="hljs-string">an</span> <span class="hljs-string">existing</span> <span class="hljs-string">EC2</span> <span class="hljs-string">KeyPair</span> <span class="hljs-string">to</span> <span class="hljs-string">enable</span> <span class="hljs-string">SSH</span> <span class="hljs-string">access</span> <span class="hljs-string">into</span> <span class="hljs-string">the</span> <span class="hljs-string">WordPress</span> <span class="hljs-string">web</span> <span class="hljs-string">server</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">AWS::EC2::KeyPair::KeyName</span><br>  <span class="hljs-attr">WordPressUser:</span><br>    <span class="hljs-attr">Default:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">NoEcho:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">Description:</span> <span class="hljs-string">The</span> <span class="hljs-string">WordPress</span> <span class="hljs-string">database</span> <span class="hljs-string">admin</span> <span class="hljs-string">account</span> <span class="hljs-string">user</span> <span class="hljs-string">name</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">String</span><br>    <span class="hljs-attr">MinLength:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">MaxLength:</span> <span class="hljs-number">16</span><br>    <span class="hljs-attr">AllowedPattern:</span> <span class="hljs-string">&quot;[a-zA-Z][a-zA-Z0-9]*&quot;</span><br>  <span class="hljs-attr">WebServerPort:</span><br>    <span class="hljs-attr">Default:</span> <span class="hljs-number">8888</span><br>    <span class="hljs-attr">Description:</span> <span class="hljs-string">TCP/IP</span> <span class="hljs-string">port</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">WordPress</span> <span class="hljs-string">web</span> <span class="hljs-string">server</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">Number</span><br>    <span class="hljs-attr">MinValue:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">MaxValue:</span> <span class="hljs-number">65535</span><br></code></pre></td></tr></table></figure><h3 id="3-Mappings"><a href="#3-Mappings" class="headerlink" title="3. Mappings"></a>3. Mappings</h3><p>更加灵活的将值与值做映射。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Parameters:</span><br>  <span class="hljs-attr">KeyName:</span><br>    <span class="hljs-attr">Description:</span> <span class="hljs-string">Name</span> <span class="hljs-string">of</span> <span class="hljs-string">an</span> <span class="hljs-string">existing</span> <span class="hljs-string">EC2</span> <span class="hljs-string">KeyPair</span> <span class="hljs-string">to</span> <span class="hljs-string">enable</span> <span class="hljs-string">SSH</span> <span class="hljs-string">access</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">instance</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">String</span><br><span class="hljs-attr">Mappings:</span><br>  <span class="hljs-attr">RegionMap:</span><br>    <span class="hljs-attr">us-east-1:</span><br>      <span class="hljs-attr">AMI:</span> <span class="hljs-string">ami-76f0061f</span><br>    <span class="hljs-attr">us-west-1:</span><br>      <span class="hljs-attr">AMI:</span> <span class="hljs-string">ami-655a0a20</span><br>    <span class="hljs-attr">eu-west-1:</span><br>      <span class="hljs-attr">AMI:</span> <span class="hljs-string">ami-7fd4e10b</span><br>    <span class="hljs-attr">ap-southeast-1:</span><br>      <span class="hljs-attr">AMI:</span> <span class="hljs-string">ami-72621c20</span><br>    <span class="hljs-attr">ap-northeast-1:</span><br>      <span class="hljs-attr">AMI:</span> <span class="hljs-string">ami-8e08a38f</span><br><span class="hljs-attr">Resources:</span><br>  <span class="hljs-attr">Ec2Instance:</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">&#x27;AWS::EC2::Instance&#x27;</span><br>    <span class="hljs-attr">Properties:</span><br>      <span class="hljs-attr">KeyName:</span> <span class="hljs-type">!Ref</span> <span class="hljs-string">KeyName</span><br>      <span class="hljs-attr">ImageId:</span> <span class="hljs-type">!FindInMap</span> <span class="hljs-comment"># 对于不同的AWS::Region，自动采用不同的AMI</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">RegionMap</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-type">!Ref</span> <span class="hljs-string">&#x27;AWS::Region&#x27;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AMI</span><br>      <span class="hljs-attr">UserData:</span> <span class="hljs-type">!Base64</span> <span class="hljs-string">&#x27;80&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-Outputs"><a href="#4-Outputs" class="headerlink" title="4. Outputs"></a>4. Outputs</h3><p>stack输出的log</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Outputs:</span><br>  <span class="hljs-attr">InstallURL:</span><br>    <span class="hljs-attr">Value:</span> <span class="hljs-type">!Join</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;http://&#x27;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-type">!GetAtt</span> <br>          <span class="hljs-bullet">-</span> <span class="hljs-string">ElasticLoadBalancer</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">DNSName</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/wp-admin/install.php</span><br>    <span class="hljs-attr">Description:</span> <span class="hljs-string">Installation</span> <span class="hljs-string">URL</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">WordPress</span> <span class="hljs-string">website</span><br>  <span class="hljs-attr">WebsiteURL:</span><br>    <span class="hljs-attr">Value:</span> <span class="hljs-type">!Join</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;http://&#x27;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-type">!GetAtt</span> <br>          <span class="hljs-bullet">-</span> <span class="hljs-string">ElasticLoadBalancer</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">DNSName</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AWS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS CloudFormation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf</title>
    <link href="/2022/06/01/protobuf/"/>
    <url>/2022/06/01/protobuf/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://developers.google.com/protocol-buffers?hl=en">https://developers.google.com/protocol-buffers?hl=en</a></p></blockquote><p>数据序列化和结构化的方案常见的有：xml, json, yaml等以及protobuf。</p><p>序列化：将<strong>结构数据</strong>或<strong>对象</strong>转换成<strong>能够被存储和传输（例如网络传输）的格式</strong>，同时应当要保证这个序列化结果在之后（可能在另一个计算环境中）能够被重建回原来的结构数据或对象。数据序列化侧重于效率和压缩。</p><p>结构化：侧重数据的可读性。标记性语言更多侧重于数据的结构化。</p><p>protobuf能够很好的压缩数据，但是可读性上相对较差。</p><h1 id="2-protobuf的优势"><a href="#2-protobuf的优势" class="headerlink" title="2. protobuf的优势"></a>2. protobuf的优势</h1><p><a href="https://www.jianshu.com/p/a24c88c0526a">https://www.jianshu.com/p/a24c88c0526a</a></p><ul><li>可以在python，c++, java等主流编程语言中共享数据。使用protobuf语法编写的.proto文件（定义存储的数据结构）可以由protobuf的编译器编译生成不同语言的类文件，用于访问以及生成数据，类文件中提供各种相关的api。</li><li>序列化后的数据可跨语言共享：序列化后的数据(.prototxt)在各语言中格式一致，并能够被各语言的protobuf api读取以及访问，从而实现的数据的跨语言共享。</li><li>简单来说：protobuf被多语言支持（提供了生成多语言类文件的编译器，这些类文件可以生成并读写数据），比XML更加轻量易读。</li></ul><h1 id="3-protobuf的使用"><a href="#3-protobuf的使用" class="headerlink" title="3. protobuf的使用"></a>3. protobuf的使用</h1><h2 id="1-定义message"><a href="#1-定义message" class="headerlink" title="1.定义message"></a>1.定义message</h2><blockquote><p><a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p></blockquote><p><code>=1,=2</code> tag用于在encoding的二进制文件中代表不同的属性，因此将repeated的属性用小的tag值，将不常用的属性用大的tag值，能够在一定程度上优化存储。</p><p><code>optional</code>属性若不设定则为其默认值，而required属性则必须设定。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto2&quot;</span>;<br><span class="hljs-keyword">package</span> tutorial;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span> id = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">PhoneType</span> &#123;<br>    MOBILE = <span class="hljs-number">0</span>;<br>    HOME = <span class="hljs-number">1</span>;<br>    WORK = <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">message </span><span class="hljs-title class_">PhoneNumber</span> &#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">optional</span> PhoneType type = <span class="hljs-number">2</span> [default = HOME];<br>  &#125;<br>  <span class="hljs-keyword">repeated</span> PhoneNumber phones = <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">message </span><span class="hljs-title class_">AddressBook</span> &#123;<br>  <span class="hljs-keyword">repeated</span> Person people = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-编译protobuf"><a href="#2-编译protobuf" class="headerlink" title="2.编译protobuf"></a>2.编译protobuf</h2><p>使用protobuf的编译器protoc编译.proto文件，生成对应的class。对应python_out，有不同对应的语言支持。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto<br><span class="hljs-meta prompt_"># </span><span class="language-bash">protoc -I=./ --python_out=./ ./addressbook.proto</span><br></code></pre></td></tr></table></figure><p>生成<strong>address_pb2.py</strong>文件，_pb2为添加的后缀。</p><ul><li>不同于其他的语言，python不直接生成对应的class，而是使用特殊的descriptor的方法描述message，可以理解成一个生成 class的模版。通过metaclass方法，如type，使用descriptor定义的属性字典，动态生成python class。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(message.Message):<br>  <span class="hljs-comment"># metaclass是用于生成class的模版</span><br>  __metaclass__ = reflection.GeneratedProtocolMessageType<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span>(message.Message):<br>    __metaclass__ = reflection.GeneratedProtocolMessageType<br>    DESCRIPTOR = _PERSON_PHONENUMBER<br>  <span class="hljs-comment"># 在load时，GeneratedProtocolMessageType metaclass使用descriptor来生成对应的python module</span><br>  DESCRIPTOR = _PERSON<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddressBook</span>(message.Message):<br>  __metaclass__ = reflection.GeneratedProtocolMessageType<br>  DESCRIPTOR = _ADDRESSBOOK<br></code></pre></td></tr></table></figure><ul><li>descriptor的定义：实际上是attr dict</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">_ADDRESSBOOK = _descriptor.Descriptor(<br>  name=<span class="hljs-string">&#x27;AddressBook&#x27;</span>,<br>  full_name=<span class="hljs-string">&#x27;tutorial.AddressBook&#x27;</span>,<br>  filename=<span class="hljs-literal">None</span>,<br>  file=DESCRIPTOR,<br>  containing_type=<span class="hljs-literal">None</span>,<br>  create_key=_descriptor._internal_create_key,<br>  fields=[<br>    _descriptor.FieldDescriptor(<br>      name=<span class="hljs-string">&#x27;people&#x27;</span>, full_name=<span class="hljs-string">&#x27;tutorial.AddressBook.people&#x27;</span>, index=<span class="hljs-number">0</span>,<br>      number=<span class="hljs-number">1</span>, <span class="hljs-built_in">type</span>=<span class="hljs-number">11</span>, cpp_type=<span class="hljs-number">10</span>, label=<span class="hljs-number">3</span>,<br>      has_default_value=<span class="hljs-literal">False</span>, default_value=[],<br>      message_type=<span class="hljs-literal">None</span>, enum_type=<span class="hljs-literal">None</span>, containing_type=<span class="hljs-literal">None</span>,<br>      is_extension=<span class="hljs-literal">False</span>, extension_scope=<span class="hljs-literal">None</span>,<br>      serialized_options=<span class="hljs-literal">None</span>, file=DESCRIPTOR,  create_key=_descriptor._internal_create_key),<br>  ],<br>  extensions=[<br>  ],<br>  nested_types=[],<br>  enum_types=[<br>  ],<br>  serialized_options=<span class="hljs-literal">None</span>,<br>  is_extendable=<span class="hljs-literal">False</span>,<br>  syntax=<span class="hljs-string">&#x27;proto2&#x27;</span>,<br>  extension_ranges=[],<br>  oneofs=[<br>  ],<br>  serialized_start=<span class="hljs-number">249</span>,<br>  serialized_end=<span class="hljs-number">296</span>,<br>)<br></code></pre></td></tr></table></figure><ul><li>生成class的代码</li></ul><p>通过**_reflection.GeneratedProtocolMessageType()**方法生成message对应的python模块与api</p><p>**_reflection.GeneratedProtocolMessageType()**实际上是类似于type()的metaclass方法，用于动态生成python的class</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">AddressBook = _reflection.GeneratedProtocolMessageType(<span class="hljs-string">&#x27;AddressBook&#x27;</span>, (_message.Message,), &#123;<br>  <span class="hljs-string">&#x27;DESCRIPTOR&#x27;</span> : _ADDRESSBOOK,<br>  <span class="hljs-string">&#x27;__module__&#x27;</span> : <span class="hljs-string">&#x27;address_pb2&#x27;</span><br>  <span class="hljs-comment"># @@protoc_insertion_point(class_scope:tutorial.AddressBook)</span><br>  &#125;)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">https://github.com/protocolbuffers/protobuf/blob/87dd07b4367b7676af42105d0d102f4e536c248b/python/google/protobuf/internal/python_message.py</span><br><span class="hljs-string">class GeneratedProtocolMessageType(type) 动态创建对应的class对象</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-读写protobuf"><a href="#3-读写protobuf" class="headerlink" title="3.读写protobuf"></a>3.读写protobuf</h2><ul><li>api</li></ul><blockquote><p><a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated">https://developers.google.com/protocol-buffers/docs/reference/python-generated</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> addressbook_pb2<br>person = addressbook_pb2.Person()<br><span class="hljs-built_in">print</span>(person.<span class="hljs-built_in">id</span>)  <span class="hljs-comment"># 未定义的属性返回其默认值</span><br>person.<span class="hljs-built_in">id</span> = <span class="hljs-number">1234</span><br><span class="hljs-comment"># 类型必须一致且属性必须存在</span><br>person.not_exist_field = <span class="hljs-number">10</span> <span class="hljs-comment"># error raised</span><br>person.name = <span class="hljs-string">&quot;John Doe&quot;</span><br>person.email = <span class="hljs-string">&quot;jdoe@example.com&quot;</span><br>phone = person.phones.add()<br>phone.number = <span class="hljs-string">&quot;555-4321&quot;</span><br><br><span class="hljs-comment"># enum的值为int</span><br>phone.<span class="hljs-built_in">type</span> = addressbook_pb2.Person.HOME <span class="hljs-comment"># or addressbook_pb2.Person.PhoneType.HOME</span><br></code></pre></td></tr></table></figure><ul><li>序列化和反序列化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = person.SerializeToString()<br><span class="hljs-comment"># 得到二进制的字符串</span><br><span class="hljs-comment"># s = b&#x27;\n\x08John Doe\x10\xd2\t\x1a\x10jdoe@example.com&quot;\x0c\n\x08555-4321\x10\x01&#x27;</span><br>new_person = addressbook_pb2.Person()<br>new_person.ParseFromString(s) <span class="hljs-comment">#反序列化</span><br></code></pre></td></tr></table></figure><h1 id="4-protobuf的编码"><a href="#4-protobuf的编码" class="headerlink" title="4. protobuf的编码"></a>4. protobuf的编码</h1><ul><li>varint编码方案</li></ul><blockquote><p><a href="https://izualzhy.cn/protobuf-encode-varint-and-zigzag">https://izualzhy.cn/protobuf-encode-varint-and-zigzag</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/encoding">https://developers.google.com/protocol-buffers/docs/encoding</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;varint编码简介</span><br><span class="hljs-string">a = 197, varint(a) = 0xC5_01, 转为二进制 0b11000101_00000001</span><br><span class="hljs-string">转换过程：</span><br><span class="hljs-string">1. 每个byte的最高位代表后续的byte是否属于这个数字，比如0b11000101_00000001中</span><br><span class="hljs-string">第一个字节的最高位1表示第二个字节属于本数，第二个字节最高位0代表本数字的结束</span><br><span class="hljs-string">2. 去掉每个字节的最高位，并调换字节的顺序后拼接</span><br><span class="hljs-string">7位     7位</span><br><span class="hljs-string">0000001_1000101 = 197</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>varint编码实现了不定长的整形数据编码，能够为序列化节省一定的空间。</p><ul><li>实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">message Test1 &#123;</span><br><span class="hljs-string">  optional int32 a = 1;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">并设定 a = 197, 序列化后得到 b&#x27;\x08\xc5\x01&#x27;</span><br><span class="hljs-string">\xc5\x01 代表a的值为197，是197的varint编码</span><br><span class="hljs-string"></span><br><span class="hljs-string">protobuf message是一系列的键值对，键为(field_number &lt;&lt; 3) | wire_type</span><br><span class="hljs-string">因此,0x08表示wire_type = 0, field_number = 1</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br></code></pre></td></tr></table></figure><ul><li>ZigZag编码</li></ul><p>ZigZag是将有符号数统一映射到无符号数的一种编码方案，对于无符号数<code>0 1 2 3 4</code>，映射前的有符号数分别为<code>0 -1 1 -2 2</code>，负数以及对应的正数来回映射到从0变大的数字序列里，这也是”zig-zag”的名字来源。</p><p>也就是说</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span> :<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">abs</span>(n) - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>转换后可以使用varint编码，绝对值较小的负数占用较少的空间。</p>]]></content>
    
    
    <categories>
      
      <category>protobuf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>protobuf</tag>
      
      <tag>数据序列化</tag>
      
      <tag>数据结构化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2022/06/01/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/01/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote><p><a href="https://blog.csdn.net/qq_28063811/article/details/93034625/">https://blog.csdn.net/qq_28063811/article/details/93034625/</a></p><p><a href="https://blog.csdn.net/weixin_50941083/article/details/121096435">https://blog.csdn.net/weixin_50941083/article/details/121096435</a></p></blockquote><p>堆是一种完全二叉树的数据结构。由于完全二叉树的性质，对于每个节点，都能推算出其父节点和左右子节点的索引。因此堆可以用数组来表示。</p><p>大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</p><p>小顶堆：每个节点的值都小于或者等于它的左右子节点的值。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ol><li><p>对于一个完全二叉树上的节点<code>i</code>，其左右子节点index为<code>2*i+1</code>和<code>2*i+2</code>,父节点index为<code>(i-1)//2</code></p><ol><li>假设<code>i</code>所在层为<code>n</code>（该层元素个数为$ 2 ^ {n} $,等于其所有上层元素个数和➕1），<code>i</code>所在层前方有<code>k</code>个元素。则有 $i &#x3D; 2^{n} - 1 + k$</li><li>对于其左子节点<code>j</code>, 有 $ j &#x3D; 2^{n+1} - 1 + 2*k$。所以 $ j &#x3D; 2 * i + 1 $，右子节点为 $ 2 * i + 2$</li><li>同理算出父节点index</li><li>最后一个父节点为尾节点的父节点，即为$ (len - 1 - 1) &#x2F;&#x2F; 2 &#x3D; len &#x2F;&#x2F; 2 - 1$</li></ol></li><li><p>大顶堆堆顶的元素是最大的元素，小顶堆堆顶的元素是最小的元素</p></li><li><p>堆排序的基本思想是：</p><ol><li>将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；</li><li>将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；</li><li>重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。</li></ol></li><li><p>复杂度分析：</p><ol><li>交换及重建大顶堆的过程中，需要交换n-1次，重建大顶堆的过程根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为O(nlog(n))</li><li><code>heap_insert</code>初始化大顶堆时间复杂度为O(nlog(n))。 <code>heapify</code>则为O(n)</li></ol></li></ol><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><h2 id="1-heap-insert初始化"><a href="#1-heap-insert初始化" class="headerlink" title="1. heap_insert初始化"></a>1. heap_insert初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_sort</span>(<span class="hljs-params">arr: <span class="hljs-type">List</span></span>):<br>    <span class="hljs-comment"># 第一步: 使用heap_insert将初始的数组构建为大顶堆</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):<br>        heap_insert(arr, index)<br><br>    <span class="hljs-comment"># 第二步: 逐个将堆顶与堆尾交换, 堆尾-1, 并将其重新调整为大顶堆</span><br>    heapsize = <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> heapsize &gt; <span class="hljs-number">0</span>:<br>        arr[<span class="hljs-number">0</span>], arr[heapsize] = arr[heapsize], arr[<span class="hljs-number">0</span>] <span class="hljs-comment"># 交换最大节点和最后一个子节点</span><br>        heapsize -= <span class="hljs-number">1</span><br>        heapify(arr, heapsize)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_insert</span>(<span class="hljs-params">arr: <span class="hljs-type">List</span>, index: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;调整索引为index处, 使得arr[0:index+1]为大顶堆</span><br><span class="hljs-string">    适用于初始阶段, 调整整个arr成为大顶堆.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 如果新加入的节点值大于其父节点, 则交换。其他分支不受影响</span><br>    parent_index = (index-<span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> parent_index &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> arr[index] &gt; arr[parent_index]:<br>        arr[index], arr[parent_index] = arr[parent_index], arr[index]<br>        index = parent_index<br>        parent_index = (index-<span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr: <span class="hljs-type">List</span>, index: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对于一个大顶堆, 堆顶和index+1值交换后, 重新调整, 使得arr[0:index+1]为大顶堆。</span><br><span class="hljs-string">    复杂度为log(n)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= index:<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span> &lt;= index:  <span class="hljs-comment"># 左右节点均存在</span><br>            swap_index = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>] &gt; arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            swap_index = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> arr[i] &lt; arr[swap_index]:<br>            arr[i], arr[swap_index] = arr[swap_index], arr[i]<br>            i = swap_index<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="2-heapify初始化"><a href="#2-heapify初始化" class="headerlink" title="2. heapify初始化"></a>2. heapify初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_sort</span>(<span class="hljs-params">arr: <span class="hljs-type">List</span></span>):<br>    <span class="hljs-comment"># 第一步: 使用build_max_heap将初始的数组构建为大顶堆</span><br>    build_max_heap(arr)<br><br>    <span class="hljs-comment"># 第二步: 逐个将堆顶与堆尾交换, 堆尾-1, 并将其重新调整为大顶堆</span><br>    heapsize = <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> heapsize &gt; <span class="hljs-number">0</span>:<br>        arr[<span class="hljs-number">0</span>], arr[heapsize] = arr[heapsize], arr[<span class="hljs-number">0</span>] <span class="hljs-comment"># 交换最大节点和最后一个子节点</span><br>        heapsize -= <span class="hljs-number">1</span><br>        heapify(arr, <span class="hljs-number">0</span>, heapsize)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_max_heap</span>(<span class="hljs-params">arr: <span class="hljs-type">List</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;从第一个非叶子节点开始，从右至左，从下至上调整子树为大根堆，最终整个堆为大根堆</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    i = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span> - <span class="hljs-number">1</span> <span class="hljs-comment">#第一个非叶子节点</span><br>    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:<br>        heapify(arr, i, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>)<br>        i -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr: <span class="hljs-type">List</span>, start: <span class="hljs-built_in">int</span>, index: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;重新调整, 使得arr[start:index+1]为大顶堆</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    i = start<br>    <span class="hljs-keyword">while</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= index:<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span> &lt;= index:  <span class="hljs-comment"># 左右节点均存在</span><br>            swap_index = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>] &gt; arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            swap_index = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> arr[i] &lt; arr[swap_index]:<br>            arr[i], arr[swap_index] = arr[swap_index], arr[i]<br>            i = swap_index<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h1 id="4-解题"><a href="#4-解题" class="headerlink" title="4. 解题"></a>4. 解题</h1><blockquote><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_max_heap</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;从第一个非叶子节点开始，从右至左，从下至上调整子树为大根堆，最终整个堆为大根堆</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    i = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:<br>        heapify(arr, i, <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>)<br>        i -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr, start, index</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;重新调整, 使得arr[start:index+1]为大顶堆</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    i = start<br>    <span class="hljs-keyword">while</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= index:<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span> &lt;= index:  <span class="hljs-comment"># 左右节点均存在</span><br>            swap_index = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>] &gt; arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            swap_index = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> arr[i] &lt; arr[swap_index]:<br>            arr[i], arr[swap_index] = arr[swap_index], arr[i]<br>            i = swap_index<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 第一步: 使用build_max_heap将初始的数组构建为大顶堆</span><br>        build_max_heap(nums)<br><br>        <span class="hljs-comment"># 第二步: 逐个将堆顶与堆尾交换, 堆尾-1, 并将其重新调整为大顶堆</span><br>        heapsize = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        idx = k<br>        <span class="hljs-keyword">while</span> heapsize &gt; <span class="hljs-built_in">len</span>(nums) - k - <span class="hljs-number">1</span>:<br>            nums[<span class="hljs-number">0</span>], nums[heapsize] = nums[heapsize], nums[<span class="hljs-number">0</span>] <span class="hljs-comment"># 交换最大节点和最后一个子节点</span><br>            heapsize -= <span class="hljs-number">1</span><br>            heapify(nums, <span class="hljs-number">0</span>, heapsize)<br>        <span class="hljs-keyword">return</span> nums[-k]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap sort</tag>
      
      <tag>leetcode-排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 不同路径</title>
    <link href="/2022/05/26/leetcode-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/05/26/leetcode-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不同路径I"><a href="#1-不同路径I" class="headerlink" title="1.不同路径I"></a>1.不同路径I</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p></blockquote><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><h2 id="1-排列组合法"><a href="#1-排列组合法" class="headerlink" title="1.排列组合法"></a>1.排列组合法</h2><p>总步数只可能是m+n-2步，最终到达终点。其实m-1步向下，n-1步向右。自然可以看作是一个组合问题，从m+n-2中选择m-1个位置，让机器人向下，其他n-1位置向右。答案为$C_{m+n-2}^{m-1}$.</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>            res *= i<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.factorial(m+n-<span class="hljs-number">2</span>) // (self.factorial(m-<span class="hljs-number">1</span>) * self.factorial(n-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h2><p>任何一个格子只能从左边或者上方到达，因此有<code>nums[i][j] = nums[i-1][j] + nums[i][j-1]</code>。同时只需要使用额外<code>O(n)</code>的内存，不需要使用<code>O(m*n)</code>或者<code>O(2n)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cur = [<span class="hljs-number">1</span>] * n<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m-<span class="hljs-number">1</span>): <span class="hljs-comment"># for the rest m-1 rows</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> j != <span class="hljs-number">0</span>:<br>                    cur[j] = cur[j-<span class="hljs-number">1</span>] + cur[j] <span class="hljs-comment"># save space, use one row</span><br>        <span class="hljs-keyword">return</span> cur[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="2-不同路径II"><a href="#2-不同路径II" class="headerlink" title="2. 不同路径II"></a>2. 不同路径II</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-paths-ii/">https://leetcode.cn/problems/unique-paths-ii/</a></p></blockquote><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p></blockquote><h2 id="1-错误的做法：递归"><a href="#1-错误的做法：递归" class="headerlink" title="1. 错误的做法：递归"></a>1. 错误的做法：递归</h2><p>思想是：一个点到终点的路径数等于右边到终点的路径数加上下边到终点的路径数。比较直观。但是递归过程中会有大量的重复运算。比如找<code>self.helper(obstacleGrid, i+1, j, row_len, col_len)</code>和<code>self.helper(obstacleGrid, i, j+1, row_len, col_len)</code>会重复计算重合的长方形，导致超出时间限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 超出时间限制🚫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">self, obstacleGrid, i, j, row_len, col_len</span>):<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> res<br>        <span class="hljs-keyword">if</span> i == row_len - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j == col_len - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> i &lt; row_len - <span class="hljs-number">1</span>:<br>            res += self.helper(obstacleGrid, i+<span class="hljs-number">1</span>, j, row_len, col_len)<br>        <span class="hljs-keyword">if</span> j &lt; col_len - <span class="hljs-number">1</span>:<br>            res += self.helper(obstacleGrid, i, j+<span class="hljs-number">1</span>, row_len, col_len)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type obstacleGrid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.helper(obstacleGrid, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(obstacleGrid), <span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>]))<br><br></code></pre></td></tr></table></figure><h2 id="2-动态规划-1"><a href="#2-动态规划-1" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h2><p>类似于上一题的做法，只是需要额外判断一个点是否是障碍物。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空间复杂度O(m*n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type obstacleGrid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = [<br>            [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> col] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> obstacleGrid<br>        ]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(obstacleGrid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>                    res[i][j] = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">0</span>:<br>                    res[i][j] = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> i == <span class="hljs-number">0</span>:<br>                    res[i][j] = res[i][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-number">0</span>:<br>                    res[i][j] = res[i-<span class="hljs-number">1</span>][j]<br>                <span class="hljs-keyword">else</span>:<br>                    res[i][j] = res[i][j-<span class="hljs-number">1</span>] + res[i-<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> res[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>优化空间复杂度为<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type obstacleGrid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>]))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(obstacleGrid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>                    res[j] = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                        res[j] = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        res[j] = res[j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> j != <span class="hljs-number">0</span>:<br>                        res[j] = res[j-<span class="hljs-number">1</span>] + res[j]<br>        <span class="hljs-keyword">return</span> res[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="3-不同路径III"><a href="#3-不同路径III" class="headerlink" title="3. 不同路径III"></a>3. 不同路径III</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-paths-iii/">https://leetcode.cn/problems/unique-paths-iii/</a></p></blockquote><blockquote><p>在二维网格 grid 上，有 4 种类型的方格：</p><p>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。</p><p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。</strong></p></blockquote><p>没有比较好的做法，只有去四个方向搜索，判断每条路径是否经过了所有无障碍空格。对于每个递归，在递归退出之前重置障碍点，可以节省很多的递归空间消耗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">self, grid, cur, steps</span>):<br>        <span class="hljs-keyword">if</span> cur[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cur[<span class="hljs-number">0</span>] &gt;= self.row_len <span class="hljs-keyword">or</span> cur[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cur[<span class="hljs-number">1</span>] &gt;= self.col_len:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> grid[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>:<br>            self.res += (steps == self.steps)<br>        <span class="hljs-keyword">elif</span> grid[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:<br>            grid[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = -<span class="hljs-number">1</span><br>            <span class="hljs-comment"># up</span><br>            self.helper(grid, [cur[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>, cur[<span class="hljs-number">1</span>]], steps+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># down</span><br>            self.helper(grid, [cur[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, cur[<span class="hljs-number">1</span>]], steps+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># left</span><br>            self.helper(grid, [cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>], steps+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># right</span><br>            self.helper(grid, [cur[<span class="hljs-number">0</span>], cur[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>], steps+<span class="hljs-number">1</span>)<br>            grid[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePathsIII</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.steps = <span class="hljs-number">1</span> <span class="hljs-comment"># attention</span><br>        self.row_len = <span class="hljs-built_in">len</span>(grid)<br>        self.col_len = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.row_len):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.col_len):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">0</span>:<br>                    self.steps += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> grid[i][j] == <span class="hljs-number">1</span>:<br>                    cur = [i, j]<br>                    grid[i][j] = <span class="hljs-number">0</span><br>        self.res = <span class="hljs-number">0</span><br>        self.helper(grid, cur, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_tips</title>
    <link href="/2022/05/17/python-tips/"/>
    <url>/2022/05/17/python-tips/</url>
    
    <content type="html"><![CDATA[<h1 id="1-python版本管理"><a href="#1-python版本管理" class="headerlink" title="1. python版本管理"></a>1. python版本管理</h1><p>Linux发行版自带的python解释器被多个系统组件所依赖，如ubuntu20.04自带的python3.8.10。强行<code>sudo ln -sf /usr/bin/python3.9 /usr/bin/python3</code>会造成系统组件无法开启，比如terminal无响应，应该禁止使用这种覆盖系统python解释器的做法。推荐使用<a href="https://github.com/pyenv/pyenv">pyenv</a>来管理python解释版本。</p><h1 id="2-偏函数partial"><a href="#2-偏函数partial" class="headerlink" title="2. 偏函数partial"></a>2. 偏函数partial</h1><blockquote><p><a href="https://stackoverflow.com/questions/15331726/how-does-functools-partial-do-what-it-does">https://stackoverflow.com/questions/15331726/how-does-functools-partial-do-what-it-does</a></p></blockquote><p>functools提供的partial高阶函数操作，用于简化原始函数的调用方式，使用args和kwargs来覆盖原函数的部分参数，使得调用更加简单。</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c, d=<span class="hljs-number">1</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span> * a + <span class="hljs-number">100</span> * b + <span class="hljs-number">10</span> * c + d<br><br>partial_add = partial(add, <span class="hljs-number">2</span>, d=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># partial函数使得第一个位置参数a始终为2，关键字参数d预设为5</span><br><span class="hljs-built_in">print</span>(partial_add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment"># 2345</span><br><span class="hljs-built_in">print</span>(partial_add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, d=<span class="hljs-number">6</span>)) <span class="hljs-comment"># 2346</span><br><br><span class="hljs-comment"># 在调用int方法时，始终将base设置为2</span><br>basetwo = partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br>basetwo.__doc__ = <span class="hljs-string">&#x27;Convert base 2 string to an int.&#x27;</span><br><span class="hljs-built_in">print</span>(basetwo(<span class="hljs-string">&#x27;10010&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 偏函数的实现</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">func, *part_args, **part_kwargs</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*extra_args, **extra_kwargs</span>):<br>        args = <span class="hljs-built_in">list</span>(part_args)<br>        args.extend(extra_args)<br>        kwargs = &#123;**part_kwargs, **extra_kwargs&#125; <span class="hljs-comment">#关键字参数可以在调用时覆盖</span><br>        <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><h1 id="3-exec的用法"><a href="#3-exec的用法" class="headerlink" title="3.exec的用法"></a>3.exec的用法</h1><blockquote><p><a href="https://docs.python.org/3/library/functions.html#exec">https://docs.python.org/3/library/functions.html#exec</a></p></blockquote><p>exec可以动态的执行一段存储在string中的python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">code = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">def fibo(n):</span><br><span class="hljs-string">    a = 0</span><br><span class="hljs-string">    b = 1</span><br><span class="hljs-string">    for i in range(n-2):</span><br><span class="hljs-string">        b, a = a+b, b</span><br><span class="hljs-string">    return b</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-built_in">exec</span>(code)<br><span class="hljs-built_in">print</span>(fibo(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">code = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">def add_a(n):</span><br><span class="hljs-string">    return a + n</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>env = &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">100</span>&#125;<br><span class="hljs-built_in">exec</span>(code, env)  <span class="hljs-comment">#不同于上面的情况，add_a函数只存在于env globals作用域下</span><br><span class="hljs-built_in">print</span>(env[<span class="hljs-string">&quot;add_a&quot;</span>])<br><span class="hljs-built_in">print</span>(env[<span class="hljs-string">&quot;add_a&quot;</span>](<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h1 id="4-函数参数中的-x2F-和"><a href="#4-函数参数中的-x2F-和" class="headerlink" title="4. 函数参数中的&#x2F;和*"></a>4. 函数参数中的&#x2F;和*</h1><blockquote><p><a href="https://www.zhihu.com/question/287097169">https://www.zhihu.com/question/287097169</a></p></blockquote><p><code>*</code>后的参数必须使用关键字的方式调用，不能用位置参数的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, *, b, c</span>):<br>    <span class="hljs-keyword">return</span> a + b + c<br><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;/Users/noname/Desktop/yunwei/test.py&quot;, line 4, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(add(1, 2, 3))</span><br><span class="hljs-comment"># TypeError: add() takes 1 positional argument but 3 were given</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>, c=<span class="hljs-number">3</span>)) <span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure><p><code>/</code>前的参数必须使用位置参数的调用形式，而不能使用关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, /, c</span>):<br>    <span class="hljs-keyword">return</span> a + b + c<br><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>, c=<span class="hljs-number">3</span>))<br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;/Users/noname/Desktop/yunwei/test.py&quot;, line 4, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(add(1, b=2, c=3))</span><br><span class="hljs-comment"># TypeError: add() got some positional-only arguments passed as keyword arguments: &#x27;b&#x27;</span><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, c=<span class="hljs-number">3</span>))  <span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure><h1 id="5-globals-和locals"><a href="#5-globals-和locals" class="headerlink" title="5. globals()和locals()"></a>5. globals()和locals()</h1><blockquote><p><a href="https://stackoverflow.com/questions/7969949/whats-the-difference-between-globals-locals-and-vars">https://stackoverflow.com/questions/7969949/whats-the-difference-between-globals-locals-and-vars</a></p></blockquote><p>locals() 返回是当前局部变量的深拷贝，修改locals() 中变量值的时候，实际上对于原变量本身是没有任何影响的。<br>而globals()返回的是全局变量的字典，修改其中的内容，值会真正的发生改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-number">1000</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    c = <span class="hljs-number">100</span><br>    local_vars = <span class="hljs-built_in">locals</span>()<br>    <span class="hljs-built_in">print</span>(local_vars)<br>    <span class="hljs-comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 10, &#x27;c&#x27;: 100&#125;</span><br>    local_vars[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">200</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">locals</span>())<br>    <span class="hljs-comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 10, &#x27;c&#x27;: 100, &#x27;local_vars&#x27;: &#123;...&#125;&#125;</span><br>    global_vars = <span class="hljs-built_in">globals</span>()<br>    <span class="hljs-built_in">print</span>(global_vars)<br>    <span class="hljs-comment"># &#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None,</span><br>    <span class="hljs-comment"># &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x108397340&gt;,</span><br>    <span class="hljs-comment">#  &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;,</span><br>    <span class="hljs-comment"># &#x27;__file__&#x27;: &#x27;/Users/noname/Desktop/yunwei/test.py&#x27;,</span><br>    <span class="hljs-comment"># &#x27;__cached__&#x27;: None, &#x27;d&#x27;: 1000, &#x27;add&#x27;: &lt;function add at 0x1083890d0&gt;&#125;</span><br>    global_vars[<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-number">2000</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">globals</span>())<br>    <span class="hljs-comment"># &#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None,</span><br>    <span class="hljs-comment"># &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x108397340&gt;,</span><br>    <span class="hljs-comment"># &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;,</span><br>    <span class="hljs-comment"># &#x27;__file__&#x27;: &#x27;/Users/noname/Desktop/yunwei/test.py&#x27;, &#x27;</span><br>    <span class="hljs-comment"># __cached__&#x27;: None, &#x27;d&#x27;: 2000, &#x27;add&#x27;: &lt;function add at 0x1083890d0&gt;&#125;</span><br><br>    <span class="hljs-keyword">return</span> a + b + c + d<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br>    <span class="hljs-comment"># 2111 对locals的修改不生效，对globals的修改会生效</span><br></code></pre></td></tr></table></figure><h1 id="6-functools-wraps"><a href="#6-functools-wraps" class="headerlink" title="6. functools.wraps"></a>6. functools.wraps</h1><blockquote><p><a href="https://stackoverflow.com/questions/308999/what-does-functools-wraps-do">https://stackoverflow.com/questions/308999/what-does-functools-wraps-do</a></p></blockquote><p>用于将装饰器装饰的原始函数的docstring，name，参数列表等复制到被装饰后的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">with_logging</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(func.__name__ + <span class="hljs-string">&quot; was called&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> with_logging<br><br><span class="hljs-meta">@logged</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;does some math&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x + x * x<br><br><span class="hljs-built_in">print</span>(f.__name__)  <span class="hljs-comment"># prints &#x27;f&#x27;</span><br><span class="hljs-built_in">print</span>(f.__doc__)   <span class="hljs-comment"># prints &#x27;does some math&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python-tips</tag>
      
      <tag>python配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言基础</title>
    <link href="/2022/05/17/c/"/>
    <url>/2022/05/17/c/</url>
    
    <content type="html"><![CDATA[<h2 id="1-指针"><a href="#1-指针" class="headerlink" title="1.指针"></a>1.指针</h2><h4 id="1-指针和指针变量"><a href="#1-指针和指针变量" class="headerlink" title="1. 指针和指针变量"></a>1. <strong>指针</strong>和<strong>指针变量</strong></h4><p><strong>指针</strong>：代表一个内存地址</p><p><strong>指针变量</strong>：存放指针的变量，指针变量的类型是存放的地址指向的变量的数据类型</p><p><strong>变量名</strong>：编译器会将变量名存放到一个<strong>符号表</strong>中，每个符号对应一个地址。当调用变量时，按照符号找到对应的地址。然后进行操作。</p><p><img src="/2022/05/17/c/%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F.png" alt="指针和指针变量"></p><ul><li><strong>取地址运算符</strong>&amp; 和**取值运算符 ***</li></ul><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *pa = &amp;a; <span class="hljs-comment">//指针变量pa指向a，pa中存放的地址为a的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,*pa); <span class="hljs-comment">//取值</span><br></code></pre></td></tr></table></figure><p>避免访问未初始化的指针：可能会覆盖其他的数据</p><h4 id="2-指针和数组"><a href="#2-指针和数组" class="headerlink" title="2. 指针和数组"></a>2. 指针和数组</h4><p><strong>数组名</strong>是数组中第一个元素的地址</p><p><strong>指向数组的指针</strong>：将数组的首地址存放到指针变量中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">char</span> *p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-type">char</span> *p = a;<br></code></pre></td></tr></table></figure><p><strong>指针的运算</strong>：指针指向数组后，可以进行加减运算。相当于在数组中向前后移动n个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(p+<span class="hljs-number">1</span>)); <span class="hljs-comment">//指向下一个元素</span><br></code></pre></td></tr></table></figure><p><strong>使用指针定义和访问数组：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello world&quot;</span>; <span class="hljs-comment">//str指向数组的第一个元素</span><br><span class="hljs-type">int</span> i, length;<br>length = <span class="hljs-built_in">strlen</span>(str);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,str[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>指针和数组名的区别</strong>：</p><p>数组名是地址常量，而指针变量是变量，可以作为左值(lvalue)。而数组名不可以作为左值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-type">char</span> *target = str; <span class="hljs-comment">//数组名是地址常量，不可以作为左值</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (*target++ != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>    count++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,count);<br></code></pre></td></tr></table></figure><p><strong>指针数组</strong>和<strong>数组指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p1[<span class="hljs-number">5</span>]; <span class="hljs-comment">//指针数组，每个数组元素存放一个指针变量，初始化为多个指针</span><br><span class="hljs-type">char</span> *p[<span class="hljs-number">2</span>] = &#123;<br>    <span class="hljs-string">&quot;Hello&quot;</span>,<br>    <span class="hljs-string">&quot;World&quot;</span><br>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,*(p[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>));<br><span class="hljs-type">int</span> (*p2)[<span class="hljs-number">5</span>]; <span class="hljs-comment">//数组指针，指向一个数组</span><br><span class="hljs-comment">/* 使用指针指向数组时，下面的指针p实际上指向的是一个整型变量（也就是数组的第一个元素），</span><br><span class="hljs-comment">而不是指向这个数组 */</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = a;<br><br><span class="hljs-comment">// 定义数组指针，存放数组首地址的地址，相当于二级指针</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> (*p2)[<span class="hljs-number">5</span>] = &amp;a; <span class="hljs-comment">//取出数组的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(*p2+<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p><strong>二维数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*(array+i) == array[i] //相当于多级指针，需要多次解引用</span><br><span class="hljs-comment">*(*(array+i)+j) == array[i][j]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>二维数组</strong>和<strong>数组指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-type">int</span> (*p)[<span class="hljs-number">3</span>] = <span class="hljs-built_in">array</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,**(p+<span class="hljs-number">1</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,**(<span class="hljs-built_in">array</span>+<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h4 id="3-void指针和NULL指针"><a href="#3-void指针和NULL指针" class="headerlink" title="3. void指针和NULL指针"></a>3. void指针和NULL指针</h4><p><strong>void</strong>是不确定类型，不可以用来申明变量</p><p><strong>void指针</strong>为通用指针，可以指向任意类型的数据。void指针不能解引用，编译器不能确定指向的数据类型，需要强制转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> *p = &amp;num;<br><span class="hljs-type">void</span> *a;<br>a = p;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(<span class="hljs-type">int</span> *)a); <span class="hljs-comment">//强制类型转换</span><br></code></pre></td></tr></table></figure><p><strong>NULL指针</strong>，不指向任何的数据的空指针。在指针不知道初始化为什么地址时，可以初始化为NULL。NULL用于指针和对象，指向一个不被使用的地址。’\0’表示字符串的结尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p1;<br><span class="hljs-type">int</span> *p2 = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p1); <span class="hljs-comment">//野指针，解引用后可能为任意值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p2); <span class="hljs-comment">//无法对NULL进行解引用</span><br></code></pre></td></tr></table></figure><h4 id="4-指向指针的指针"><a href="#4-指向指针的指针" class="headerlink" title="4.指向指针的指针"></a>4.指向指针的指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">1&#x27;</span>;<br><span class="hljs-type">int</span> *p = &amp;num;<br><span class="hljs-type">int</span> **pp = &amp;p; <span class="hljs-comment">//指向指针的指针，需要进行两层解引用</span><br></code></pre></td></tr></table></figure><p><strong>指针数组和指向指针的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *p[<span class="hljs-number">2</span>] = &#123;<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;;<br><span class="hljs-type">char</span> **pp1;<br>pp1 = &amp;p[<span class="hljs-number">1</span>]; <span class="hljs-comment">//pp1指向指针p[1]</span><br><span class="hljs-type">char</span> **pp2[<span class="hljs-number">2</span>]; <span class="hljs-comment">//指向指针的指针的数组</span><br>pp2[<span class="hljs-number">0</span>] = &amp;p[<span class="hljs-number">0</span>];<br>pp2[<span class="hljs-number">1</span>] = &amp;p[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p><strong>常量和指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">//变量num只读不可以修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;num; <span class="hljs-comment">//指针指向常量，不可以通过解引用修改指向的值，但是指针的指向可以改变</span><br></code></pre></td></tr></table></figure><p><strong>常量指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 指针指向变量，指针本身不可以修改指向，但是指针指向的值可以修改</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;num;<br>*p = <span class="hljs-number">1024</span>;<br><span class="hljs-comment">// 指针指向常量，指针本身不可以修改指向，指针指向的值也不可以修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = &amp;cnum; <span class="hljs-comment">//指向常量的常量指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> *pp = &amp;p; <span class="hljs-comment">//指向 指向常量的常量指针 的指针</span><br></code></pre></td></tr></table></figure><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h2><p> <strong>函数的声明与定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>; <span class="hljs-comment">//声明</span><br><span class="hljs-comment">//定义</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        res += n;<br>    &#125;<span class="hljs-keyword">while</span>(n-- &gt;<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// main函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum(n));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>传值</strong>和<strong>传址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 错误的示例，作用域不同导致在main中x和y的值没有互换</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>; <span class="hljs-comment">//传入变量的副本</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp = x;<br>    x = y;<br>    y = temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">5</span>;<br>    swap(x,y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,x,y);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 传址，传给函数的是变量的地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp = *x;<br>    *x = *y;<br>    *y = temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">5</span>;<br>    swap(&amp;x,&amp;y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,x,y);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 参数为数组时，实际上传递给函数的是第一个元素的地址，也就是传入的是指针</span><br></code></pre></td></tr></table></figure><p><strong>可变参数</strong> variable argument</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n,...)</span>; <span class="hljs-comment">//n表示可变参数数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n,...)</span>&#123;<br>    <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>    va_list vap; <span class="hljs-comment">//定义参数列表</span><br>    va_start(vap,n); <span class="hljs-comment">// 初始化参数列表</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        sum += va_arg(vap, <span class="hljs-type">int</span>); <span class="hljs-comment">//获取参数值</span><br>    &#125;<br>    va_end(vap); <span class="hljs-comment">//关闭参数列表</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">5</span>, z = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum(<span class="hljs-number">3</span>,x,y,z));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>指针函数</strong>和<strong>函数指针</strong></p><p><strong>指针函数</strong>：使用指针变量作为函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getWord</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span>; <span class="hljs-comment">//返回一个指针</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getWord</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>    <span class="hljs-keyword">switch</span>(c)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;apple&quot;</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;banana&quot;</span>;<br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;None&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> input;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;input);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,getWord(input)); <span class="hljs-comment">//返回字符串首字母的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 不要返回局部变量的指针，局部变量只存在于函数中，函数结束即销毁</span><br></code></pre></td></tr></table></figure><p><strong>函数指针</strong>：指向函数的指针。在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且<strong>函数名表示的就是这个地址</strong>。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sqt</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sqt</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>    <span class="hljs-keyword">return</span> num * num;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>    fp = sqt;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(*fp)(num));<br>    <span class="hljs-comment">// printf(&quot;%d&quot;,fp(num)); 这样写也可以</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数指针作为参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>),<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a -b;<br>&#125;<br><span class="hljs-comment">// 函数名即为函数指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> (*fp)(a,b);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,calc(add,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数指针作为返回值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>),<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); <span class="hljs-comment">//函数指针作为返回值的函数声明</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a -b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> (*fp)(a,b);<br>&#125;<br><br><span class="hljs-type">int</span> (*select(<span class="hljs-type">char</span> op))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#123;<br>    <span class="hljs-keyword">switch</span>(op)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> add;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> sub;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-type">char</span> op;<br>    <span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c%d&quot;</span>,&amp;a,&amp;op,&amp;b);<br>    fp = select(op);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,calc(fp,a,b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-C语言细节"><a href="#3-C语言细节" class="headerlink" title="3. C语言细节"></a>3. C语言细节</h2><p><strong>局部变量</strong>和<strong>全局变量</strong>：函数内部定义的函数是<strong>局部变量</strong>，外部定义的是<strong>全局变量</strong></p><blockquote><p>如果在函数内部存在与全局变量同名的局部变量，则在函数中屏蔽全局变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">//告知编译器count变量在后面定义</span><br>    count++;<br>&#125;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    func();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用大量的全局变量会占用更多的内存，会污染命名空间</p></blockquote><p><strong>作用域</strong></p><ul><li><strong>代码块作用域</strong>：形参和代码块中定义的变量只在代码块内部起作用</li><li><strong>文件作用域</strong>：从声明开始到文件结束均可以使用</li><li><strong>原型作用域</strong>：只适用于在函数原型中声明的参数名</li><li><strong>函数作用域</strong>：适用于goto语句的标签</li></ul><p><strong>链接属性</strong>：static可以将external的变量表示为internal变量，显示某个变量只在本文件中被使用</p><ul><li><strong>external</strong>：多个文件中同名标识符表示一个实体</li><li><strong>internal</strong>：单个文件中同名标识符表示一个实体</li><li><strong>none</strong>：同名标识符表示不同实体</li></ul><p><strong>生存期</strong></p><ul><li><p><strong>静态存储期</strong>：文件作用域的变量具有静态存储期，程序关闭时释放</p></li><li><p><strong>自动存储期</strong>：代码块作用域的变量具有自动存储期，代码块结束时释放存储空间</p></li></ul><p><strong>变量的存储类型</strong>：指存储变量值的内存类型</p><ul><li><strong>auto 自动变量</strong></li></ul><p>默认存储类型，自动变量具有代码块作用域，自动存储期，空链接属性。默认可以不写。</p><ul><li><strong>register 寄存器变量</strong></li></ul><p>寄存器存在于cpu的内部，cpu对寄存器中数据的读取和存储几乎没有任何延迟。与自动变量类似。无法获取寄存器变量的地址。</p><ul><li><strong>static静态局部变量</strong></li></ul><p>static声明的变量具有静态存储期，生存周期和全局变量一样，程序结束时释放。作用域仍然为代码块作用域。</p><ul><li><strong>extern</strong></li></ul><p>变量在其他文件中已经定义过</p><ul><li><strong>typedef</strong> ：为数据类型定义别名，在结构体中使用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> interger;<br><span class="hljs-comment">// 相比于宏定义的直接替换，typedef是对类型的封装</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>&#125; DATE, *PDATE;<br><span class="hljs-comment">// 给结构体取别名为DATE和指针PDATE</span><br><span class="hljs-comment">// typedef简化复杂的类型声明</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR_TO_ARRAY)</span>[3]; <span class="hljs-comment">//将PTR_TO_ARRAY定义为整型数组指针</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*PTR_TO_FUN)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *(*PTR_TO_FUN)(<span class="hljs-type">int</span>); <span class="hljs-comment">//指针数组，数组元素为函数指针</span><br></code></pre></td></tr></table></figure><p><strong>动态内存管理</strong></p><ul><li><strong>malloc</strong>：申请动态内存空间，位于内存的堆上，需要主动释放内存。</li></ul><p>对内存空间进行操作：memset, memcpy, memmove, memcmp, memchr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// void *malloc(size_t size);</span><br><span class="hljs-comment">// 向系统申请分配size个字节的内存，并返回一个指向这个空间的void指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> *ptr;<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>free</strong>：释放动态内存空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// void free(void *ptr);</span><br><span class="hljs-comment">// 释放ptr指向的内存空间</span><br></code></pre></td></tr></table></figure><p><strong>内存泄漏</strong>：申请的动态内存空间应该及时释放，否则会导致内存不足。或者丢失申请内存块的地址。</p><ul><li><strong>calloc</strong>：申请并初始化一系列内存空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i;<br>    ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, <span class="hljs-number">10</span> *<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//使用memset进行初始化内存空间为0</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ptr[i]);<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// calloc分配内存空间并初始化</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">8</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-comment">// malloc分配内存空间，使用memset进行初始化</span><br><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">memset</span>(ptr, <span class="hljs-number">0</span>, <span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><ul><li><strong>realloc</strong>：重新分配内存空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> *ptr1 = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> *ptr2 = <span class="hljs-literal">NULL</span>;<br>    ptr1 = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    ptr2 = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">memcpy</span>(ptr2, ptr1, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> i, num;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>        count++;<br>        ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(ptr,count * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        ptr[count<span class="hljs-number">-1</span>] = num;<br>    &#125; <span class="hljs-keyword">while</span> (num != <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ptr[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内存管理</strong></p><p><strong>malloc</strong>分配内存会导致大量内存碎片的产生，同时有时间上的消耗</p><p><strong>内存池</strong>：程序额外维护的一个缓存区域。用户申请内存块的时候，优先在内存池中查找合适的空间。释放内存时，优先释放到内存池中。</p><p><strong>c语言的内存布局规律</strong></p><p><img src="/2022/05/17/c/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"></p><p><strong>内存地址从低至高排列：</strong></p><ul><li>代码段：存放程序执行代码的一部分，如函数</li><li>数据段：存放已初始化的全局变量和局部静态变量</li><li>BSS段：存放未初始化的全局变量和局部静态变量</li><li>堆：存放动态分配的内存段，手动申请。堆中的数据可以由不同的函数访问到。从低地址向高地址发展。</li><li>栈：存放局部变量，参数和返回值等，系统自动分配。由高地址向低地址发展。</li></ul><p><strong>c语言的预处理（#和##）</strong></p><ul><li>文件包含</li><li>宏定义</li><li>条件编译</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不带参数的宏定义，变量大写</span><br><span class="hljs-comment">// 编译器不会对宏定义进行语法检查</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> S PI * 25</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> <span class="hljs-comment">//终止宏定义</span></span><br><span class="hljs-comment">// 带参数的宏定义，括号的存在是确保运算符优先级不同导致的错误</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) (((x) &gt; (y))?(x) : (y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STR(s) # s <span class="hljs-comment">// #将实参s当做字符串处理</span></span><br><span class="hljs-comment">// ##运算符叫做记号连接运算符，可以连接两个参数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST(x,y) x ## y</span><br><span class="hljs-comment">// 输入2和1，输出21</span><br></code></pre></td></tr></table></figure><p><strong>内联函数</strong>：解决程序中函数调用的效率问题。减少了函数调用的时间消耗，但是增加了代码编译的时间。</p><h2 id="4-结构体"><a href="#4-结构体" class="headerlink" title="4. 结构体"></a>4. 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将不同的数据类型集合到一起</span><br><span class="hljs-comment">// 声明结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> title[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">char</span> author[<span class="hljs-number">40</span>];<br>    <span class="hljs-type">float</span> price;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> date;<br>    <span class="hljs-type">char</span> publisher[<span class="hljs-number">40</span>];<br>&#125;;<br><span class="hljs-comment">//定义结构体类型变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> <span class="hljs-title">book</span>;</span><br><span class="hljs-comment">//初始化结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> <span class="hljs-title">book</span> =</span> &#123;<br>  .price = <span class="hljs-number">10.8</span>,<br>  .date = <span class="hljs-number">20170912</span><br>&#125;;<br><span class="hljs-comment">//结构体的内存对齐，按四个字节进行对齐。按照定义结构体成员的位置可以减小结构的内存大小</span><br><span class="hljs-comment">// 结构体嵌套</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> title[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">float</span> price;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> <span class="hljs-title">date</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>结构体数组</strong>：数组元素为结构体，而不是基本的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义结构体数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>&#125; date[<span class="hljs-number">10</span>]; <span class="hljs-comment">//定义结构体数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> <span class="hljs-title">date</span>[10];</span><br></code></pre></td></tr></table></figure><p><strong>结构体指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> *<span class="hljs-title">pt</span>;</span> <span class="hljs-comment">//定义指向结构体的指针</span><br><span class="hljs-comment">// 结构体的变量名不是指向结构体的地址</span><br>pt = &amp;date; <span class="hljs-comment">//使用取址运算符</span><br><span class="hljs-comment">// 访问成员</span><br>(*pt).year;<br>pt-&gt;year; <span class="hljs-comment">//成员选择</span><br></code></pre></td></tr></table></figure><p><strong>传递结构体变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 结构体作为输入和输出</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体1 函数名( <span class="hljs-keyword">struct</span> 结构体2 结构体2变量)；</span><br></code></pre></td></tr></table></figure><p><strong>传递指向结构体变量的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 指向结构体变量的指针 作为输入和输出</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体1 *函数名( <span class="hljs-keyword">struct</span> 结构体2 *结构体2变量)；</span><br></code></pre></td></tr></table></figure><p><strong>动态申请结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span> *<span class="hljs-title">b1</span>;</span><br>b1 = (<span class="hljs-keyword">struct</span> Book *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Book));<br></code></pre></td></tr></table></figure><p><strong>单链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 使用结构体定义单链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-共用体"><a href="#5-共用体" class="headerlink" title="5. 共用体"></a>5. 共用体</h2><p>共用体，或者称为联合体或联合类型。共用体的所有成员同享一个内存地址，只能使用某一个成员。否则成员的值之间会互相覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> pi;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">6</span>];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Test</span> <span class="hljs-title">test</span>;</span> <span class="hljs-comment">//定义共用体类型变量</span><br>    test.i = <span class="hljs-number">10</span>;<br>    test.pi = <span class="hljs-number">1.1</span>;<br>    <span class="hljs-built_in">strcpy</span>(test.str, <span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">//值为最后赋值的成员值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;test.i); <span class="hljs-comment">// 三者的地址相同</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;test.pi);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;test.str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-枚举类型"><a href="#6-枚举类型" class="headerlink" title="6. 枚举类型"></a>6. 枚举类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Week</span> &#123;</span>sun, mom, tue, wed, thu, fri, sat&#125;; <span class="hljs-comment">//枚举常量，可以指定枚举常量的值</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Week</span> <span class="hljs-title">today</span>;</span> <span class="hljs-comment">//枚举变量</span><br></code></pre></td></tr></table></figure><p>(1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。</p><p>(2) Week是一个标识符，可以看成这个集合的名字，<strong>是一个可选项</strong>，即是可有可无的项。</p><p>(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。</p><p>(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。</p><p>(5) 枚举型是预处理指令#define的替代。</p><p>(6) 类型定义以分号**;**结束。</p><h2 id="7-位"><a href="#7-位" class="headerlink" title="7. 位"></a>7. 位</h2><p><strong>位域</strong>：能够将一个字节拆分使用，位域是字节的一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a:<span class="hljs-number">1</span>; <span class="hljs-comment">//指定变量所占的位数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> c:<span class="hljs-number">5</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  :<span class="hljs-number">10</span>; <span class="hljs-comment">//无名位域，凑空间，不可以使用</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>逻辑位运算符</strong>：对位进行运算。用于掩码，打开位，关闭位，转置位等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">~ 按位取反</span><br><span class="hljs-comment">&amp; 按位与</span><br><span class="hljs-comment">^ 按位异或(XOR)</span><br><span class="hljs-comment">| 按位或</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>移位运算符</strong>：将变量的二进制位进行左移或右移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 左移位运算符，右端抛弃，左端用0填充。右移运算符同理</span><br><span class="hljs-comment">11001010 &lt;&lt; 2</span><br><span class="hljs-comment">00101000</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (value &lt; <span class="hljs-number">1024</span>)&#123;<br>        value &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-文件操作"><a href="#8-文件操作" class="headerlink" title="8. 文件操作"></a>8. 文件操作</h2><ul><li><p><strong>文本文件</strong>和<strong>二进制文件</strong></p></li><li><p><strong>打开和关闭文件</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fopen<br>fclose<br></code></pre></td></tr></table></figure><ul><li><strong>文件读写</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//读写单个字符</span><br>fgetc <span class="hljs-comment">//函数</span><br>getc  <span class="hljs-comment">//宏</span><br>fputc <span class="hljs-comment">//函数</span><br>putc <span class="hljs-comment">//宏</span><br><span class="hljs-comment">//读写字符串</span><br>fgets<br><span class="hljs-built_in">fputs</span><br><span class="hljs-comment">// 格式化读写文件</span><br><span class="hljs-built_in">fscanf</span> <span class="hljs-comment">//从文件中获取</span><br><span class="hljs-built_in">fprintf</span> <span class="hljs-comment">//输入至文件中</span><br></code></pre></td></tr></table></figure><ul><li>二进制读写文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>C&amp;CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Action和docker自动化部署hexo博客</title>
    <link href="/2022/05/15/%E4%BD%BF%E7%94%A8Github-Action%E5%92%8Cdocker%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/05/15/%E4%BD%BF%E7%94%A8Github-Action%E5%92%8Cdocker%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo博客可以通过hexo部署到用户的github page上，此时上传至github上的文件只是hexo生成的静态网页文件。而博客的源文件以及博客的配置始终保存在本地，这样会有丢失的风险。用户最好同时将blog的源文件做好版本管理，自然而然我们可以使用github来托管blog源文件。因为在github上需要同时托管两个repo：</p><ul><li>blog仓库用来存放hexo博客的所有源文件以及配置</li><li>github.io的仓库用来托管github page的静态博客文件</li></ul><p>在本地操作的时候，需要同时用git推送blog的修改，以及使用<code>hexo d -g</code>生成博客并部署。有没有一种方案可以将博客的源代码管理以及博客的部署统一到一步完成呢。</p><p><a href="https://github.com/features/actions">Github Action</a>是实现CI&#x2F;CD的利器，使用好github action能够很方便的让测试以及部署流程自动化。</p><p>hexo的环境配置可以使用dockerfile来一键配置。docker hub上已有许多可用的hexo环境的docker image。为了更好的使用hexo环境，我按照自己的习惯创建了一个<a href="https://github.com/WeiYUN13/hexo_in_docker">hexo的docker环境</a>，这个docker环境可以在CI中使用，自动化生成和部署博客。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>创建blog仓库用于托管博客的所有源文件以及配置</li><li>创建github.io的静态博客仓库</li><li>dockerfile用于配置CI的hexo环境</li><li>配置部署密钥至github secrets中，通过CI调用ssh部署密钥来部署博客</li></ul><h2 id="CI-workflow"><a href="#CI-workflow" class="headerlink" title="CI workflow"></a>CI workflow</h2><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>]<br><br><span class="hljs-attr">env:</span><br>  <span class="hljs-attr">GIT_USER:</span> <span class="hljs-string">WeiYUN13</span><br>  <span class="hljs-attr">GIT_EMAIL:</span> <span class="hljs-string">yunwei_ecpkn@buaa.edu.cn</span><br>  <span class="hljs-attr">GIT_SSH_KEY:</span> <span class="hljs-string">$&#123;&#123;secrets.HEXO_DEPLOY_KEY&#125;&#125;</span><br>  <span class="hljs-attr">HEXO_SERVER_PORT:</span> <span class="hljs-string">&quot;4000&quot;</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy_hexo:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span> <span class="hljs-string">hexo</span> <span class="hljs-string">blog</span> <span class="hljs-string">to</span> <span class="hljs-string">http://weiyun13.github.io</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Buildx</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">buildx</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">docker/setup-buildx-action@v1</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">build</span> <span class="hljs-string">hexo_in_docker</span> <span class="hljs-string">image</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo &quot;$GIT_SSH_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          git clone git@github.com:WeiYUN13/hexo_in_docker.git ~/hexo_in_docker</span><br><span class="hljs-string">          cd ~/hexo_in_docker &amp;&amp; docker build -t hexo_in_docker .</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">start</span> <span class="hljs-string">hexo_in_docker</span> <span class="hljs-string">container</span> <span class="hljs-string">and</span> <span class="hljs-string">deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          docker run --name=blog \</span><br><span class="hljs-string">            -e HEXO_SERVER_PORT=$HEXO_SERVER_PORT \</span><br><span class="hljs-string">            -e GIT_USER=&quot;$GIT_USER&quot; \</span><br><span class="hljs-string">            -e GIT_EMAIL=&quot;$GIT_EMAIL&quot; \</span><br><span class="hljs-string">            -e GIT_SSH_KEY=&quot;`cat ~/.ssh/id_rsa`&quot; \</span><br><span class="hljs-string">            -e DEPLOY_NOW=&quot;yes&quot; \</span><br><span class="hljs-string">            -v &quot;$GITHUB_WORKSPACE&quot;:/blog \</span><br><span class="hljs-string">            -p &quot;$HEXO_SERVER_PORT&quot;:4000 \</span><br><span class="hljs-string">            hexo_in_docker</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>Github CI</tag>
      
      <tag>docker</tag>
      
      <tag>automation</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
